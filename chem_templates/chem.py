# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_chem.ipynb.

# %% auto 0
__all__ = ['to_mol', 'to_smile', 'to_kekule', 'canon_smile', 'remove_stereo', 'remove_stereo_smile', 'Molecule',
           'mol_func_wrapper', 'smile_func_wrapper', 'Catalog', 'remove_fragment_mapping', 'is_mapped',
           'remove_fragment_dummies', 'add_fragment_mapping', 'generate_mapping_permutations', 'fragment_mol',
           'clean_fragments', 'fragment_smile', 'fragment_molecule', 'fuse_mol_on_atom_mapping',
           'fuse_smile_on_atom_mapping', 'get_dummy_mol', 'combine_dummies']

# %% ../nbs/01_chem.ipynb 3
from .imports import *
from .utils import *

import rdkit
from rdkit import Chem
from rdkit.Chem import AllChem, rdMolDescriptors, Descriptors, rdMMPA
from rdkit.Chem.FilterCatalog import FilterCatalog, ExclusionList, FilterCatalogEntry, \
SmartsMatcher, FilterCatalogParams
from rdkit import RDLogger
RDLogger.DisableLog('rdApp.*')

# %% ../nbs/01_chem.ipynb 5
def to_mol(smile: str) -> Union[Chem.Mol, None]:
    try:
        mol = Chem.MolFromSmiles(smile)
        Chem.SanitizeMol(mol)
    except:
        mol = None
        
    return mol

def to_smile(mol: Chem.Mol) -> str:
    smile = Chem.MolToSmiles(mol)
    return smile

def to_kekule(smile: str) -> str:
    return Chem.MolToSmiles(to_mol(smile), kekuleSmiles=True)

def canon_smile(smile: str) -> str:
    try:
        return Chem.CanonSmiles(smile)
    except:
        return ''
    
def remove_stereo(mol: Chem.Mol) -> Chem.Mol:
    Chem.rdmolops.RemoveStereochemistry(mol)
    return mol

def remove_stereo_smile(smile: str) -> str:
    if '@' in smile:
        mol = to_mol(smile)
        mol = remove_stereo(mol)
        smile = to_smile(mol)
    return smile

# %% ../nbs/01_chem.ipynb 7
class Molecule():
    def __init__(self, 
                 smile: str, 
                 data:  Optional[dict]=None):
        self.smile = canon_smile(smile)
        self.mol = to_mol(self.smile)
        self.valid = (self.mol is not None) and (self.smile != '')
        
        self.data = {}
        self.add_data(data)
            
    def add_data(self, data: Optional[dict]=None):
        if data is not None:
            self.data.update(data)

# %% ../nbs/01_chem.ipynb 8
def mol_func_wrapper(func: Callable[[Chem.Mol], Any]):
    return lambda molecule: func(molecule.mol)

def smile_func_wrapper(func: Callable[[str], Any]):
    return lambda molecule: func(molecule.smile)

# %% ../nbs/01_chem.ipynb 10
class Catalog():
    def __init__(self, catalog: FilterCatalog):
        self.catalog = catalog
        self.filter_names = [self.catalog.GetEntryWithIdx(i).GetDescription() 
                      for i in range(self.catalog.GetNumEntries())]
        
    def has_match(self, molecule: Molecule) -> bool:
        return self.catalog.HasMatch(molecule.mol)
    
    def get_matches(self, molecule: Molecule) -> list[str]:
        matches = [i.GetDescription() for i in self.catalog.GetMatches(molecule.mol)]
        return matches
    
    @classmethod
    def from_smarts(cls, smarts: list[str]):
        catalog = FilterCatalog()
        for s in smarts:
            catalog.AddEntry(FilterCatalogEntry(s, SmartsMatcher(s,s)))
            
        return cls(catalog)
    
    @classmethod
    def from_params(cls, params: FilterCatalogParams.FilterCatalogs):
        catalog = FilterCatalog(params)
        return cls(catalog)

# %% ../nbs/01_chem.ipynb 12
def remove_fragment_mapping(smile: str) -> str:
    patt = re.compile('\[\*(.*?)]')
    smile = patt.sub('[*]', smile)
    return canon_smile(smile)

def is_mapped(smile: str) -> bool:
    patt = re.compile('\[\*(.*?)]')
    return len(patt.findall(smile)) == smile.count('*')

def remove_fragment_dummies(smile: str) -> str:
    smile = remove_fragment_mapping(smile)
    smile = canon_smile(smile.replace('*', '[H]'))
    return smile

def add_fragment_mapping(smile:    str, 
                         map_nums: list[int]) -> str:
    
    assert smile.count('*') == len(map_nums)
    
    smile = remove_fragment_mapping(smile)
    
    new_smile = ''
    map_idx = 0
    for char in smile:
        if char=='*':
            new_smile += f'[*:{map_nums[map_idx]}]'
            map_idx += 1
        else:
            new_smile += char
            
    return new_smile

def generate_mapping_permutations(smile:    str, 
                                  map_nums: list[int], 
                                  exact:    bool=False) -> list[str]:
    
    n_attachments = smile.count('*')
    
    if map_nums is None:
        map_nums = list(range(1, n_attachments+1))
    
    if exact:
        assert n_attachments == len(map_nums)
    else:
        assert n_attachments <= len(map_nums)
    
    perms = permutations(map_nums, n_attachments)
    outputs = []
    for p in perms:
        outputs.append(add_fragment_mapping(smile, p))
        
    return outputs

# %% ../nbs/01_chem.ipynb 14
def fragment_mol(mol: Chem.Mol, 
                 cuts: list[int]) -> list[str]:
    fragments = []
    for cut in cuts:
        frags = rdMMPA.FragmentMol(mol, maxCuts=cut, resultsAsMols=False)
        frags = deduplicate_list(flatten_list(frags))
        fragments += frags
        
    fragments = deduplicate_list(fragments)
    return fragments

def clean_fragments(fragments: list[str], 
                    remove_mapping: bool=True) -> list[str]:
    patt = re.compile('\[\*(.*?)]')
    clean_fragments = []
    fragments = list(fragments)
    
    while fragments:
        current = fragments.pop()
        
        if not current:
            continue
            
        if '.' in current:
            fragments += current.split('.')
        else:
            if remove_mapping:
                current = remove_fragment_mapping(current)
                
            current = canon_smile(current)
            if current:
                clean_fragments.append(current)
                
    clean_fragments = deduplicate_list(clean_fragments)
    return clean_fragments


def fragment_smile(smile: str, 
                   cuts: list[int],
                   remove_mapping: bool=True
                  ) -> list[str]:
    
    mol = to_mol(smile)
    fragments = fragment_mol(mol, cuts)
    clean = clean_fragments(fragments, remove_mapping=remove_mapping)

    return clean

def fragment_molecule(molecule: Molecule,
                      cuts: list[int],
                      remove_mapping: bool=True
                     ) -> list[Molecule]:
    
    fragments = fragment_mol(molecule.mol, cuts)
    clean = clean_fragments(fragments, remove_mapping=remove_mapping)
    clean = [Molecule(i) for i in clean]

    return clean

# %% ../nbs/01_chem.ipynb 16
def fuse_mol_on_atom_mapping(mol: Chem.Mol) -> Union[Chem.Mol, None]:
    try:
        return Chem.molzip(mol)
    except:
        return None
    
def fuse_smile_on_atom_mapping(smile: str) -> str:
    mol = to_mol(smile)
    mol = fuse_mol_on_atom_mapping(mol)
    if mol is not None:
        return to_smile(mol)
    else:
        return ''

# %% ../nbs/01_chem.ipynb 18
def get_dummy_mol(name:     str, 
                  map_nums: list[int],
                  id:       Optional[int]=None
                 ) -> Chem.Mol:
    templates = {
        0 : '[Zr]',
        1 : '[*][Zr]',
        2 : '[*][Zr][*]',
        3 : '[*][Zr]([*])[*]',
        4 : '[*][Zr]([*])([*])[*]'
    }
    
    num_attachments = len(map_nums)
    mapping_idx = 0
    template = templates[num_attachments]
    template = add_fragment_mapping(template, map_nums)
    
    if id is not None:
        template = template.replace('Zr', f'Zr:{id}')
            
    mol = to_mol(template)
    for atom in mol.GetAtoms():
        if atom.GetAtomicNum() != 0:
            atom.SetProp('atomLabel', name)
            
    return mol

def combine_dummies(dummies: list[Chem.Mol], 
                    fuse:    bool=True) -> Chem.Mol:
    combo = Chem.MolFromSmiles('')
    for mol in dummies:
        combo = Chem.CombineMols(combo, mol)
        
    if fuse:
        combo = Chem.molzip(combo)
        
    return combo
