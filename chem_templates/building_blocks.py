# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_building_blocks.ipynb.

# %% ../nbs/06_building_blocks.ipynb 3
from __future__ import annotations

import chem_templates
from .imports import *
from .utils import *
from .chem import to_mol, to_smile, Molecule

from .synt_on.src.SyntOn_BBs import mainSynthonsGenerator
from .synt_on.src.SyntOn_Classifier import BBClassifier

from rdkit import Chem
from rdkit.Chem import rdChemReactions as Reactions
from rdkit.Chem import Draw

FUSION_REACTION_PATH = chem_templates.__path__[0] + '/synt_on/fusion_reactions'

# %% auto 0
__all__ = ['FUSION_REACTION_PATH', 'SYNTHON_VALID_COMBINATIONS', 'REACTION_GROUP_NAMES', 'REACTION_GROUPS', 'REACTION_GROUP_DICT',
           'smile_to_synthon', 'get_synthon_marks', 'prep_for_reconstruction', 'remove_reconstruction_marks',
           'BuildingBlock', 'Synthon', 'FusionReaction', 'ReactionGroup', 'ReactionUniverse']

# %% ../nbs/06_building_blocks.ipynb 4
def smile_to_synthon(smile: str, 
                     keep_pg: bool=False) -> Tuple[list[str], list[list[str]]]:
    classes = BBClassifier(mol=to_mol(smile))
    
    azoles,fSynt = mainSynthonsGenerator(smile, keep_pg, classes, returnBoolAndDict=True)

    smiles = list(fSynt.keys())
    rxns = list(fSynt.values())
    rxns = [list(i) for i in rxns]
    return smiles, rxns

# %% ../nbs/06_building_blocks.ipynb 8
def get_synthon_marks(smile: str) -> list[str]:
    pat = re.compile("\[\w*:\w*\]")
    current_marks = deduplicate_list([smile[m.start() + 1] + ":" + smile[m.end() - 3:m.end() - 1]
            for m in re.finditer(pat, smile)])
    return current_marks

# %% ../nbs/06_building_blocks.ipynb 10
SYNTHON_VALID_COMBINATIONS = {'C:10': ['N:20', 'O:20', 'C:20', 'c:20', 'n:20', 'S:20'],
                                    'c:10': ['N:20', 'O:20', 'C:20', 'c:20', 'n:20', 'S:20'],
                                    'c:20': ['N:11', 'C:10', 'c:10'], 'C:20': ['C:10', 'c:10'],
                                    'c:21': ['N:20', 'O:20', 'n:20'], 'C:21': ['N:20', 'n:20'],
                                    'N:20': ['C:10', 'c:10', 'C:21', 'c:21', 'S:10'], 'N:11': ['c:20'],
                                    'n:20': ['C:10', 'c:10', 'C:21', 'c:21'], 'O:20': ['C:10', 'c:10', 'c:21'],
                                    'S:20': ['C:10', 'c:10'], 'S:10': ['N:20'], 'C:30': ['C:40', 'N:40'],
                                    'C:40': ['C:30'], 'C:50': ['C:50'], 'C:70': ['C:60', 'c:60'],
                                    'c:60':['C:70'], 'C:60': ['C:70'], 'N:40': ['C:30'] }

def prep_for_reconstruction(smile: str) -> str:
    # augments synthon annotations (ie c:10) with dummy atoms for fusion
    labels = [10, 20, 30, 40, 50, 60, 70, 21, 11] # annotation numbers
    atomsForMarking = [23, 74, 72, 104, 105, 106, 107, 108, 109] # dummy atoms
    atomsForMarkingForDoubleBonds = [72, 104, 105]
    
    mol = to_mol(smile)
    mol = Chem.AddHs(mol)
    
    for atom in mol.GetAtoms():
        if atom.GetAtomMapNum() != 0:
            repl = atomsForMarking[labels.index(atom.GetAtomMapNum())]
            replCount = 0
            for neighbor in atom.GetNeighbors():
                if neighbor.GetAtomicNum() == 1:
                    mol.GetAtomWithIdx(neighbor.GetIdx()).SetAtomicNum(repl)
                    replCount += 1
                    if repl not in atomsForMarkingForDoubleBonds and replCount == 1:
                        break
                    elif replCount == 2:
                        break
                        
    mol = Chem.RemoveHs(mol)
    return to_smile(mol)

def remove_reconstruction_marks(smile: str) -> str:
    # removes dummy atoms for fusion
    atomsForMarking = set([23, 74, 72, 104, 105, 106, 107, 108, 109])
    mol = to_mol(smile)
    
    for atom in mol.GetAtoms():
        if atom.GetAtomicNum() in atomsForMarking:
            atom.SetAtomicNum(1)
            
    mol = Chem.AddHs(mol)
    mol = Chem.RemoveHs(mol)
            
    return to_smile(mol)

# %% ../nbs/06_building_blocks.ipynb 12
class BuildingBlock(Molecule):
    def __init__(self, 
                 smile:          str, 
                 synthon_smiles: Optional[list[str]]=None,
                 reaction_tags:  Optional[list[str]]=None,
                 data:           Optional[dict]=None):
        super().__init__(smile, data)
        
        self.synthons = []
        
        if synthon_smiles is None:
            synthon_smiles, reaction_tags = smile_to_synthon(smile)
        
        for synthon_smile, reaction_tags in zip(synthon_smiles, reaction_tags):
            recon_smile = prep_for_reconstruction(synthon_smile)
            synthon = Synthon(synthon_smile, recon_smile, [self], list(reaction_tags), None)
            self.synthons.append(synthon)
    
class Synthon(Molecule):
    def __init__(self, 
                 synthon_smile:        str, 
                 reconstruction_smile: str, 
                 parents:              list[Molecule], 
                 reaction_tags:        list[str], 
                 data:                 Optional[dict]=None):
        
        # synthon smile used for template
        # reconstruction smile used for fusing
        super().__init__(synthon_smile, data)
        self.parents = parents
        self.reaction_tags = reaction_tags
        
        self.reconstruction_smile = reconstruction_smile
        self.reconstruction_mol = to_mol(reconstruction_smile)
        
        self.marks = set(get_synthon_marks(self.reconstruction_smile))
        self.compatible_marks = set(flatten_list([SYNTHON_VALID_COMBINATIONS[i] for i in self.marks]))
        
    def is_compatible(self, synthon):
        overlaps = self.compatible_marks.intersection(synthon.marks)
        return bool(overlaps)

# %% ../nbs/06_building_blocks.ipynb 17
class FusionReaction():
    def __init__(self, name: str, rxn_smarts: str):
        self.name = name
        self.rxn_smarts = rxn_smarts
        self.rxn = Reactions.ReactionFromSmarts(rxn_smarts)
        self.rxn.Initialize()
        
    def is_reactant(self, synthon1: Synthon, synthon2: Optional[Synthon]=None) -> bool:
        
        if synthon2 is None:
            output = self.rxn.IsMoleculeReactant(synthon1.reconstruction_mol)
        else:
            reactants = self.rxn.GetReactants()
            try:
                order1 = [synthon1.reconstruction_mol.HasSubstructMatch(reactants[0]),
                          synthon2.reconstruction_mol.HasSubstructMatch(reactants[1])]
                
                order2 = [synthon2.reconstruction_mol.HasSubstructMatch(reactants[0]),
                          synthon1.reconstruction_mol.HasSubstructMatch(reactants[1])]
        
                output = all(order1) or all(order2)
            except:
                output = False
            
        return output
    
    def _react(self, synthon1: Synthon, synthon2: Synthon) -> list[str]:
        products = self.rxn.RunReactants((synthon1.reconstruction_mol, 
                                          synthon2.reconstruction_mol))
        if not products:
            products = self.rxn.RunReactants((synthon2.reconstruction_mol, 
                                          synthon1.reconstruction_mol))

        if products:
            products = flatten_list(products)
        else:
            products = []
            
        products = [to_smile(i) for i in products]
        return products
    
    def react(self, synthon1: Synthon, synthon2: Synthon) -> list[Synthon]:
        products = self._react(synthon1, synthon2)
        outputs = []
        for recon_smile in products:
            synthon_smile = remove_reconstruction_marks(recon_smile)
            result = Synthon(synthon_smile, recon_smile, [synthon1, synthon2], [self.name], None)
            outputs.append(result)
        return outputs
    
    def react_to_dict(self, synthon1: Synthon, synthon2: Synthon) -> list[dict]:
        products = self._react(synthon1, synthon2)
        outputs = []
        for recon_smile in products:
            synthon_smile = remove_reconstruction_marks(recon_smile)
            
            result = {
                'synthon_smile' : synthon_smile,
                'reconstruction_smile' : recon_smile,
                'reaction_tags' : self.name
            }            
            outputs.append(result)
        return outputs
    
    def __repr__(self):
        return f'Reaction: {self.name}'

# %% ../nbs/06_building_blocks.ipynb 19
class ReactionGroup():
    # holds reactions beloning to the same type of transform
    def __init__(self, name: str, reactions: list[FusionReaction]):
        self.name = name
        self.reactions = reactions
        
    def get_matching_reactions(self, 
                               synthon1: Synthon, 
                               synthon2: Optional[Synthon]=None) -> list[FusionReaction]:
        return [i for i in self.reactions if i.is_reactant(synthon1, synthon2)]
    
    def dump(self) -> dict:
        output = {
            'name' : self.name,
            'reactions' : [
                {'name' : i.name, 'smarts' : i.rxn_smarts} for i in self.reactions
            ]
        }
        return output
        
    @classmethod
    def from_dict(cls, input_dict: dict) -> ReactionGroup:
        reactions = [FusionReaction(i['name'], i['smarts']) for i in input_dict.get('reactions', [])]
        return cls(input_dict['name'], reactions)
    
    @classmethod
    def from_file(cls, filename: str) -> ReactionGroup:
        with open(filename, 'r') as f:
            input_dict = json.load(f)
            return cls.from_dict(input_dict)
    
    def __repr__(self):
        return f'Reaction Class: {self.name}' + '\n\t'.join([i.__repr__() for i in self.reactions])

# %% ../nbs/06_building_blocks.ipynb 20
REACTION_GROUP_NAMES = ['O-acylation',
 'Olefination',
 'Condensation_of_Y-NH2_with_carbonyl_compounds',
 'Amine_sulphoacylation',
 'C-C couplings',
 'Radical_reactions',
 'N-acylation',
 'O-alkylation_arylation',
 'Metal organics C-C bong assembling',
 'S-alkylation_arylation',
 'Alkylation_arylation_of_NH-lactam',
 'Alkylation_arylation_of_NH-heterocycles',
 'Amine_alkylation_arylation']

REACTION_GROUPS = [ReactionGroup.from_file(f'{FUSION_REACTION_PATH}/{i}.json') for i in REACTION_GROUP_NAMES]
REACTION_GROUP_DICT = {i.name : i for i in REACTION_GROUPS}

# %% ../nbs/06_building_blocks.ipynb 22
class ReactionUniverse():
    def __init__(self, 
                 name: str, 
                 reaction_groups: list[ReactionGroup]):
        self.name = name
        self.reaction_groups = reaction_groups
        self.reaction_groups_dict = {i.name : i for i in self.reaction_groups}
        
    def add_group(self, reaction_group: ReactionGroup):
        self.reaction_groups.append(reaction_group)
        self.reaction_groups_dict[reaction_group.name] = reaction_group
        
    def get_matching_reactions(self, 
                               synthon1: Synthon, 
                               synthon2: Optional[Synthon]=None) -> list[FusionReaction]:
        outputs = []
        for group in self.reaction_groups:
            outputs += group.get_matching_reactions(synthon1, synthon2)
        return outputs
