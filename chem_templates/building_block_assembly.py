# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/07_building_block_assembly.ipynb.

# %% ../nbs/07_building_block_assembly.ipynb 3
from __future__ import annotations
from .imports import *
from .utils import *
from .building_blocks import Synthon, BuildingBlock, ReactionGroup, ReactionUniverse, REACTION_GROUPS
from .template import Template, TemplateResult

# %% auto 0
__all__ = ['AssemblyPool', 'BuildingBlockNode', 'SynthonNode', 'ReactionNode', 'create_assemblies', 'fuse_assembly',
           'ProductNode']

# %% ../nbs/07_building_block_assembly.ipynb 4
class AssemblyPool():
    def __init__(self, synthons: Optional[Synthon]=None):
        self.synthons = []
        self.mark_to_synthon = defaultdict(list)
        if synthons:
            for synthon in synthons:
                self.add_synthon(synthon)
                
    def __len__(self):
        return len(self.synthons)
        
    def add_synthon(self, synthon: Synthon):
        self.synthons.append(synthon)
        for mark in synthon.marks:
            self.mark_to_synthon[mark].append(synthon)
            
    def reaction_filter(self, rxn_universe: ReactionUniverse) -> AssemblyPool:
        valid = []
        for synthon in self.synthons:
            if rxn_universe.get_matching_reactions(synthon):
                valid.append(synthon)
                
        return AssemblyPool(valid)
    
    def get_matching(self, query_synthon: Synthon) -> list[Synthon]:
        matching_synthons = []
        for mark in query_synthon.compatible_marks:
            matching_synthons += self.mark_to_synthon[mark]
            
        return deduplicate_list(matching_synthons)

# %% ../nbs/07_building_block_assembly.ipynb 5
class BuildingBlockNode():
    def __init__(self, name: str, template: Optional[Template]=None):
        self.name = name
        self.template = template
        self.n_func = set()
        
    def template_screen(self, synthon: Synthon, store_data: bool=True) -> TemplateResult:
        if self.template is not None:
            output = self.template(synthon)
        else:
            output = TemplateResult(True, [], [])
        
        if store_data:
            synthon.add_data({'template_data' : output, 'template_result' : output.result})
            
        return output
    
    def synthon_screen(self, synthon: Synthon) -> bool:
        n_func = synthon.reconstruction_smile.count(':')
        if (n_func in self.n_func) or (not self.n_func):
            template_result = self.template_screen(synthon)
            return template_result.result
        else:
            return False

# %% ../nbs/07_building_block_assembly.ipynb 6
class SynthonNode(BuildingBlockNode):
    def __init__(self, 
                 name: str, 
                 n_func: Optional[set[int]],
                 template: Optional[Template]=None):
        super().__init__(name, template)
        self.n_func = n_func
        
    def assemble(self, assembly_dict: dict) -> AssemblyPool:
        pool = assembly_dict.get(self.name)
        pool = AssemblyPool([i for i in pool.synthons if self.synthon_screen(i)])
        return pool

# %% ../nbs/07_building_block_assembly.ipynb 7
class ReactionNode(BuildingBlockNode):
    def __init__(self, 
                 name: str, 
                 reaction_universe: ReactionUniverse):
        super().__init__(name, None)
        self.reaction_universe = reaction_universe
        
    def filter_pool(self, pool: AssemblyPool) -> AssemblyPool:
        return pool.reaction_filter(self.reaction_universe)

# %% ../nbs/07_building_block_assembly.ipynb 8
def create_assemblies(incoming_pool, next_pool, rxn_universe):
    incoming_pool = incoming_pool.reaction_filter(rxn_universe)
    next_pool = next_pool.reaction_filter(rxn_universe)
    
    assemblies = []
    for synthon in incoming_pool.synthons:
        matches = next_pool.get_matching(synthon)
        for match in matches:
            valid_rxns = rxn_universe.get_matching_reactions(synthon, match)
            if valid_rxns:
                assemblies.append((synthon, match, valid_rxns))
        
    return assemblies

def fuse_assembly(inputs):
    s1, s2, valid_rxns = inputs
    product_dicts = []
    for rxn in valid_rxns:
        product_dicts += rxn.react_to_dict(s1, s2)
        
    unique_products = defaultdict(list)
    for prod in product_dicts:
        unique_products[prod['synthon_smile']].append(prod)
        
    outputs = []
    for k,v in unique_products.items():
        prod = Synthon(v[0]['synthon_smile'], v[0]['reconstruction_smile'], 
                       [s1, s2], [i['reaction_tags'] for i in v])
        outputs.append(prod)
    return outputs

class ProductNode(BuildingBlockNode):
    def __init__(self, 
                 name: str, 
                 incoming_node: Union[SynthonNode, ProductNode], 
                 reaction_node: ReactionNode,
                 next_node: Union[SynthonNode, ProductNode],
                 n_func: Optional[set[int]],
                 template: Optional[Template]=None
                ):
        super().__init__(name, template)
        
        self.incoming_node = incoming_node
        self.reaction_node = reaction_node
        self.next_node = next_node
        
    def assemble(self, assembly_dict: dict) -> AssemblyPool:
        incoming_pool = self.incoming_node.assemble(assembly_dict)
        incoming_pool = self.reaction_node.filter_pool(incoming_pool)
        
        next_pool = self.next_node.assemble(assembly_dict)
        next_pool = self.reaction_node.filter_pool(next_pool)
        
        assemblies = create_assemblies(incoming_pool, next_pool, self.reaction_node.reaction_universe)
        
        with Pool(processes=os.cpu_count()) as p:
            products = p.map(fuse_assembly, assemblies)
            
        products = AssemblyPool(flatten_list(products))
        products = AssemblyPool([i for i in products.synthons if self.synthon_screen(i)])
        return products
