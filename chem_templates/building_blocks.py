# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/06_building_blocks.ipynb.

# %% auto 0
__all__ = ['BB_PATH', 'BB_CLASS_NAMES', 'BB_CLASSES', 'check_mapped_valence', 'add_mapping_label', 'Mapping',
           'add_multiple_mappings', 'MappedReaction', 'TransformBlock', 'BuildingBlockSchema', 'BuildingBlockClass',
           'ReactionUniverse', 'BuildingBlock']

# %% ../nbs/06_building_blocks.ipynb 3
import chem_templates
from .imports import *
from .utils import *
from .chem import Molecule, to_mol, canon_smile, to_smile
from rdkit.Chem import rdChemReactions
from rdkit import Chem

BB_PATH = chem_templates.__path__[0] + '/building_block_schemas'

# %% ../nbs/06_building_blocks.ipynb 4
def check_mapped_valence(smiles: str, 
                         mapping_start: str) -> bool:
    targets = {"C": 4, "N": 3, "N+": 4, "O": 2, "S:10": 6, "S:20": 2}
    mol = to_mol(smiles)
    if mol is None:
        return False
    
    mapped_atoms = [atom for atom in mol.GetAtoms() if atom.GetAtomMapNum() != 0]
    map_nums = [atom.GetAtomMapNum() for atom in mapped_atoms]
    mapped_symbols = [atom.GetSymbol() for atom in mapped_atoms]
    for i in range(len(mapped_atoms)):
        if mapped_symbols[i] == 'S':
            if mapped_atoms[i].GetTotalValence() < targets[f'{mapped_symbols[i]}:{map_nums[i]}']:
                return False
            
        elif '+' in mapping_start:
            if mapped_atoms[i].GetTotalValence() < targets['N+']:
                return False
            
        else:
            if mapped_atoms[i].GetTotalValence() < targets[mapped_symbols[i]]:
                return False
            
    return True


def add_mapping_label(smiles: str, 
                mapping_start: str, 
                mapping_end: str) -> Union[str, None]:
    
    if 'S' in mapping_start:
        label = '[' + mapping_end.replace(':', 'H:') + ']'
        new_smile = smiles.replace(mapping_start, label)
        return canon_smile(new_smile)
    
    elif ('+' in mapping_start) and ('H' in mapping_start):
        # N+ special case, no valence check
        prev_smile = None
        possible_labels = ['[' + mapping_end.replace(':', f"H{i}:") + ']' for i in range(1, 5)]
        for pl in possible_labels:
            new_smile = smiles.replace(mapping_start, pl)
            new_mol = to_mol(new_smile)
            if new_mol:
                prev_smile = new_smile
            else:
                return canon_smile(prev_smile)
    
    else:
        charge_term = '+' if '+' in mapping_start else ''
        possible_labels = ['[' + mapping_end.replace(':', f"H{i}{charge_term}:") + ']' for i in range(1, 5)]
    
        for pl in possible_labels:
            new_smile = smiles.replace(mapping_start, pl)
            new_mol = to_mol(new_smile)
            if new_mol and check_mapped_valence(new_smile, mapping_start):
                return canon_smile(new_smile)
        
    return None

# %% ../nbs/06_building_blocks.ipynb 6
class Mapping():
    def __init__(self, mapping_start, mapping_end):
        self.mapping_start = mapping_start
        self.mapping_end = mapping_end
        
    def map_smile(self, smile):
        if self.mapping_start in smile:
            smile = add_mapping_label(smile, self.mapping_start, self.mapping_end)
        return smile
    
    def dump(self):
        return {'mapping_start' : self.mapping_start, 
                'mapping_end' : self.mapping_end}
    
    @classmethod
    def from_dict(cls, input_dict):
        return cls(input_dict['mapping_start'], input_dict['mapping_end'])
    
    def __repr__(self):
        return f'Mapping: {self.mapping_start} -> {self.mapping_end}'
    
def add_multiple_mappings(smile, mappings):
    stack = [smile]
    outputs = []
    
    while stack:
        current = stack.pop()
        for mapping in mappings:
            labeled = mapping.map_smile(current)
            if (labeled is not None) and (labeled != current):
                if '*' in labeled:
                    stack.append(labeled)
                else:
                    outputs.append(labeled)
                    
    return deduplicate_list(outputs) if outputs else [smile]

# %% ../nbs/06_building_blocks.ipynb 8
class MappedReaction():
    def __init__(self, rxn_smarts, mappings, is_deprotection=False):
        self.rxn_smarts = rxn_smarts
        self.rxn = rdChemReactions.ReactionFromSmarts(self.rxn_smarts)
        self.rxn.Initialize()
        self.mappings = mappings
        self.is_deprotection = is_deprotection
        
    def match(self, mol):
        return self.rxn.IsMoleculeReactant(mol)
    
    def map_product(self, smile):
        if (not self.is_deprotection):
            smiles = add_multiple_mappings(smile, self.mappings)
        else:
            smiles = [smile]
        return smiles
    
    def react(self, smile):
        mol = to_mol(smile)
        products = flatten_list(self.rxn.RunReactants((mol,)))
        products = [to_smile(i) for i in products]
        products = flatten_list([self.map_product(i) for i in products])
        return deduplicate_list(products)
    
    def dump(self):
        output = {
            'rxn_smarts' : self.rxn_smarts,
            'is_deprotection' : self.is_deprotection,
            'mappings' : [i.dump() for i in self.mappings]
        }
        return output
        
    @classmethod
    def from_dict(cls, input_dict):
        mappings = [Mapping.from_dict(i) for i in input_dict['mappings']]
        return cls(input_dict['rxn_smarts'], mappings, input_dict['is_deprotection'])
    
    def __repr__(self):
        if self.is_deprotection:
            output = f'Reaction: deprotection'
        else:
            output = f'Reaction: {len(self.mappings)} mappings'
        return output

# %% ../nbs/06_building_blocks.ipynb 10
class TransformBlock():
    def __init__(self, rxns):
        self.rxns = rxns
        
    def transform_smile(self, smile, include_input=False):
        outputs = []
        mol = to_mol(smile)
        
        for rxn in self.rxns:
            if rxn.match(mol):
                outputs += rxn.react(smile)
                
        return outputs
    
    def transform(self, smiles, include_input=False, flatten=True):
        outputs = [self.transform_smile(i, include_input=include_input) for i in smiles]
        if flatten:
            outputs = deduplicate_list(flatten_list(outputs))
        return outputs
    
    def dump(self):
        return {'rxns' : [i.dump() for i in self.rxns]}
    
    @classmethod
    def from_dict(cls, input_dict):
        rxns = [MappedReaction.from_dict(i) for i in input_dict['rxns']]
        return cls(rxns)
    
    def __repr__(self):
        return f"TransformBlock: {', '.join([i.__repr__() for i in self.rxns])}"

# %% ../nbs/06_building_blocks.ipynb 12
class BuildingBlockSchema():
    def __init__(self,
                 name,
                 smarts_match_any,
                 smarts_match_all,
                 smarts_match_none,
                 n_func,
                 n_pg,
                 transforms
                ):
        
        self.name = name
        
        self.smarts_match_any = smarts_match_any
        self.smarts_match_any_mols = [Chem.MolFromSmarts(i) for i in smarts_match_any]
        
        self.smarts_match_all = smarts_match_all
        self.smarts_match_all_mols = [Chem.MolFromSmarts(i) for i in smarts_match_all]
        
        self.smarts_match_none = smarts_match_none
        self.smarts_match_none_mols = [Chem.MolFromSmarts(i) for i in smarts_match_none]
        
        self.n_func = n_func
        self.n_pg = n_pg
        
        self.transforms = transforms
        
    def _check_match_any(self, mol: Chem.Mol) -> bool:
        for substruct in self.smarts_match_any_mols:
            if mol.HasSubstructMatch(substruct):
                return True
        return False
    
    def _check_match_all(self, mol: Chem.Mol) -> bool:
        for substruct in self.smarts_match_all_mols:
            if not mol.HasSubstructMatch(substruct):
                return False
        return True
    
    def _check_match_none(self, mol: Chem.Mol) -> bool:
        for substruct in self.smarts_match_none_mols:
            if mol.HasSubstructMatch(substruct):
                return False
        return True
        
    def match(self, mol: Chem.Mol) -> bool:
        return self._check_match_any(mol) and self._check_match_all(mol) and self._check_match_none(mol)
    
    def transform_smile(self, smile, return_sequence=False):
        sequence = []
        inputs = [smile]
        sequence.append(inputs)
        
        for tfm in self.transforms:
            inputs = tfm.transform(inputs, flatten=True)
            sequence.append(inputs)
            
        if return_sequence:
            return (inputs, sequence)
        else:
            return inputs
        
    def dump(self):
        output = {
            'schema_name' : self.name,
            'smarts_match_any' : self.smarts_match_any,
            'smarts_match_all' : self.smarts_match_all,
            'smarts_match_none' : self.smarts_match_none,
            'n_func' : self.n_func,
            'n_pg' : self.n_pg,
            'transforms' : [i.dump() for i in self.transforms]
        }
        return output
    
    @classmethod
    def from_dict(cls, input_dict):
        tfms = [TransformBlock.from_dict(i) for i in input_dict['transforms']]
        return cls(input_dict['schema_name'], 
                   input_dict['smarts_match_any'], 
                   input_dict['smarts_match_all'], 
                   input_dict['smarts_match_none'],
                   input_dict['n_func'],
                   input_dict['n_pg'],
                   tfms
                  )

# %% ../nbs/06_building_blocks.ipynb 15
class BuildingBlockClass():
    def __init__(self, name, schemas):
        self.name = name
        self.schemas = schemas
        self.schema_dict = {i.name:i for i in self.schemas}
        
    def match(self, mol):
        output = {}
        for schema in self.schemas:
            if schema.match(mol):
                output[schema.name] = schema
                
        if output:
            output = {self.name : output}
            
        return output
    
    def add_schema(self, schema):
        self.schemas.append(schema)
        
    def dump(self):
        return {'class_name' : self.name, 'schemas' : [i.dump() for i in self.schemas]}
    
    @classmethod
    def from_dict(cls, input_dict):

        schemas = [BuildingBlockSchema.from_dict(i) for i in input_dict['schemas']]
        return cls(input_dict['class_name'], schemas)
    
    @classmethod
    def from_file(cls, filename):
        with open(filename, 'r') as f:
            input_dict = json.load(f)
            return cls.from_dict(input_dict)

# %% ../nbs/06_building_blocks.ipynb 16
BB_CLASS_NAMES = [
        'SecondaryAmines',
        'Acylhalides',
        'SulfonesSulfinates',
        'Reagents',
        'Bifunctional',
        'ArylHalide',
        'Anhydrides',
        'Boronics',
        'Alkenes',
        'Acetylenes',
        'AlkylHalides',
        'Aldehyde',
        'Ketones',
        'Amides',
        'TertiaryAmines',
        'ElementOrganics',
        'SulfonylHalides',
        'PrimaryAmines',
        'Trifunctional',
        'Alcohols',
        'nHAzoles',
        'Azides',
        'Esters',
        'Aminoacids',
        'Acid',
        'ReagentsForOlefination'
]

BB_CLASSES = {i : BuildingBlockClass.from_file(f'{BB_PATH}/{i}.json') for i in BB_CLASS_NAMES}

# %% ../nbs/06_building_blocks.ipynb 18
class ReactionUniverse():
    def __init__(self, 
                 universe_name: str, 
                 building_block_classes: list[BuildingBlockClass]):
        self.universe_name = universe_name
        self.building_block_classes = building_block_classes
        self.building_block_class_dict = {i.name : i for i in self.building_block_classes}
        
    def add_class(self, bb_class: BuildingBlockClass):
        self.building_block_classes.append(bb_class)
        self.building_block_class_dict[bb_class.name] = bb_class
        
    def match(self, mol: Chem.Mol) -> dict:
        return {k: v for d in [i.match(mol) for i in self.building_block_classes] for k, v in d.items()}
        
    def dump(self):
        return {'universe_name' : self.universe_name, 
                'building_block_classes' : [i.dump() for i in self.building_block_classes]}
        
        
    @classmethod
    def from_dict(cls, input_dict: dict):
        name = input_dict['universe_name']
        building_block_classes = [BuildingBlockClass.from_dict(i) for i in input_dict['building_block_classes']]
        return cls(name, building_block_classes)
        
    @classmethod
    def from_file(cls, filename):
        with open(filename, 'r') as f:
            input_dict = json.load(f)
            return cls.from_dict(input_dict)
        


# %% ../nbs/06_building_blocks.ipynb 20
class BuildingBlock(Molecule):
    def __init__(self, 
                 smile: str, 
                 data:  Optional[dict]=None):
        super().__init__(smile, data)
        
    def match_schema(self, schema: BuildingBlockSchema) -> bool:
        return schema.match(self.mol)
    
    def match_class(self, bb_class: BuildingBlockClass) -> dict:
        return bb_class.match(self.mol)
    
    def match_universe(self, rxn_universe: ReactionUniverse) -> dict:
        return rxn_universe.match(self.mol)
    
    def classify(self, rxn_universe: ReactionUniverse) -> dict:
        matches = self.match_universe(rxn_universe)
        self.add_data({rxn_universe.universe_name : matches})
        return matches
