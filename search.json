[
  {
    "objectID": "chem.html",
    "href": "chem.html",
    "title": "Chem",
    "section": "",
    "text": "Functions for converting between SMILES strings and RDKit mol objects\n\nsource\n\n\n\n filter_valid_smiles (smiles:list[str])\n\ngiven a list of SMILES, filters list for SMILES that resolve to a valid molecule\n\n\n\n\nType\nDetails\n\n\n\n\nsmiles\nlist\ninput list of SMILES strings\n\n\nReturns\nlist\noutput list of valid SMILES strings\n\n\n\n\nsource\n\n\n\n\n remove_stereo_smile (smile:str)\n\nremoves stereochemistry from SMILES string\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\ninput SMILES string\n\n\nReturns\nstr\noutput SMILES string\n\n\n\n\nsource\n\n\n\n\n remove_stereo (mol:rdkit.Chem.rdchem.Mol)\n\nremoves stereochemistry from rdkit Mol\n\n\n\n\nType\nDetails\n\n\n\n\nmol\nMol\ninput rdkit Mol\n\n\nReturns\nMol\noutput rdkit Mol\n\n\n\n\nsource\n\n\n\n\n canon_smile (smile:str)\n\nattempts to canonicalize SMILES string. returns empty string if canonicalization fails\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\ninput SMILES string\n\n\nReturns\nstr\ncanonicalized SMILES string\n\n\n\n\nsource\n\n\n\n\n to_kekule (smile:str)\n\nconverts SMILES string to kekule form\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\ninput SMILES string\n\n\nReturns\nstr\noutput kekule SMILES string\n\n\n\n\nsource\n\n\n\n\n to_smile (mol:rdkit.Chem.rdchem.Mol)\n\nconverts Mol to SMILES string\n\n\n\n\nType\nDetails\n\n\n\n\nmol\nMol\ninput rdkit mol\n\n\nReturns\nstr\noutput SMILES string\n\n\n\n\nsource\n\n\n\n\n smart_to_mol (smart:str)\n\nconvertes smarts to Mol. returns None if mol creation fails\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nsmart\nstr\ninput SMARTS string\n\n\nReturns\ntyping.Optional[rdkit.Chem.rdchem.Mol]\noutput rdkit mol\n\n\n\n\nsource\n\n\n\n\n to_mol (smile:str)\n\nconvertes smile to Mol. returns None if mol creation fails\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\ninput SMILES string\n\n\nReturns\ntyping.Optional[rdkit.Chem.rdchem.Mol]\noutput rdkit mol\n\n\n\n\nassert type(to_mol('CCC')) == Chem.Mol\nassert type(to_smile(Chem.MolFromSmiles('CCC'))) == str\nassert type(smart_to_mol('[#6]')) == Chem.Mol\n\n\nsource\n\n\n\n\n Molecule (smile:str, data:Optional[dict]=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsmile\nstr\n\nSMILES string\n\n\ndata\ntyping.Optional[dict]\nNone\ndictionary of molecule data\n\n\n\n\nsource\n\n\n\n\n smile_func_wrapper (func:Callable[[str],Any])\n\ntakes a function with a SMILES string input and returns a wrapped version that accepts a Molecule as input\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfunc\ntyping.Callable[[str], typing.Any]\nfunction that takes SMILES string as input\n\n\nReturns\ntyping.Callable[[main.Molecule], typing.Any]\nfunction that takes Molecule as input\n\n\n\n\nsource\n\n\n\n\n mol_func_wrapper (func:Callable[[rdkit.Chem.rdchem.Mol],Any])\n\ntakes a function with a Chem.Mol input and returns a wrapped version that accepts a Molecule as input\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfunc\ntyping.Callable[[rdkit.Chem.rdchem.Mol], typing.Any]\nfunction that takes rdkit Mol as input\n\n\nReturns\ntyping.Callable[[main.Molecule], typing.Any]\nfunction that takes Molecule as input\n\n\n\n\nrdkit_function = rdMolDescriptors.CalcExactMolWt\n\nsmile = 'CCCCCC'\nmol = to_mol(smile)\nmolecule = Molecule(smile)\n\nwrapped_function = mol_func_wrapper(rdkit_function)\n\nassert rdkit_function(mol) == wrapped_function(molecule)\n\n\nsource\n\n\n\n\n Catalog (catalog:rdkit.Chem.rdfiltercatalog.FilterCatalog)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\nType\nDetails\n\n\n\n\ncatalog\nFilterCatalog\ninput filter catalog\n\n\n\n\nsmarts = [\n    '[*]-[#6]1:[#6]:[#6](-[#0]):[#6]:[#6](-[*]):[#6]:1',\n    '[*]-[#6]1:[#6]:[#6](-[*]):[#6]:[#6]:[#6]:1',\n    '[*]-[#6]1:[#6]:[#6]:[#6]:[#6]:[#6]:1',\n    '[*]-[#6]1:[#6]:[#6](-[#7]-[*]):[#6]:[#6]:[#6]:1',\n    '[#6]1:[#6]:[#7]:[#6]:[#6]:[#6]:1'\n]\n\ncatalog = Catalog.from_smarts(smarts)\n\nsmiles = [\n    'c1ccccc1',\n    'Cc1cccc(NCc2ccccc2)c1'\n]\n\nmolecules = [Molecule(i) for i in smiles]\n\nassert not catalog.has_match(molecules[0])\nassert catalog.has_match(molecules[1])"
  },
  {
    "objectID": "chem.html#rdkit-io",
    "href": "chem.html#rdkit-io",
    "title": "Chem",
    "section": "",
    "text": "Functions for converting between SMILES strings and RDKit mol objects\n\nsource\n\n\n\n filter_valid_smiles (smiles:list[str])\n\ngiven a list of SMILES, filters list for SMILES that resolve to a valid molecule\n\n\n\n\nType\nDetails\n\n\n\n\nsmiles\nlist\ninput list of SMILES strings\n\n\nReturns\nlist\noutput list of valid SMILES strings\n\n\n\n\nsource\n\n\n\n\n remove_stereo_smile (smile:str)\n\nremoves stereochemistry from SMILES string\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\ninput SMILES string\n\n\nReturns\nstr\noutput SMILES string\n\n\n\n\nsource\n\n\n\n\n remove_stereo (mol:rdkit.Chem.rdchem.Mol)\n\nremoves stereochemistry from rdkit Mol\n\n\n\n\nType\nDetails\n\n\n\n\nmol\nMol\ninput rdkit Mol\n\n\nReturns\nMol\noutput rdkit Mol\n\n\n\n\nsource\n\n\n\n\n canon_smile (smile:str)\n\nattempts to canonicalize SMILES string. returns empty string if canonicalization fails\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\ninput SMILES string\n\n\nReturns\nstr\ncanonicalized SMILES string\n\n\n\n\nsource\n\n\n\n\n to_kekule (smile:str)\n\nconverts SMILES string to kekule form\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\ninput SMILES string\n\n\nReturns\nstr\noutput kekule SMILES string\n\n\n\n\nsource\n\n\n\n\n to_smile (mol:rdkit.Chem.rdchem.Mol)\n\nconverts Mol to SMILES string\n\n\n\n\nType\nDetails\n\n\n\n\nmol\nMol\ninput rdkit mol\n\n\nReturns\nstr\noutput SMILES string\n\n\n\n\nsource\n\n\n\n\n smart_to_mol (smart:str)\n\nconvertes smarts to Mol. returns None if mol creation fails\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nsmart\nstr\ninput SMARTS string\n\n\nReturns\ntyping.Optional[rdkit.Chem.rdchem.Mol]\noutput rdkit mol\n\n\n\n\nsource\n\n\n\n\n to_mol (smile:str)\n\nconvertes smile to Mol. returns None if mol creation fails\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\ninput SMILES string\n\n\nReturns\ntyping.Optional[rdkit.Chem.rdchem.Mol]\noutput rdkit mol\n\n\n\n\nassert type(to_mol('CCC')) == Chem.Mol\nassert type(to_smile(Chem.MolFromSmiles('CCC'))) == str\nassert type(smart_to_mol('[#6]')) == Chem.Mol\n\n\nsource\n\n\n\n\n Molecule (smile:str, data:Optional[dict]=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsmile\nstr\n\nSMILES string\n\n\ndata\ntyping.Optional[dict]\nNone\ndictionary of molecule data\n\n\n\n\nsource\n\n\n\n\n smile_func_wrapper (func:Callable[[str],Any])\n\ntakes a function with a SMILES string input and returns a wrapped version that accepts a Molecule as input\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfunc\ntyping.Callable[[str], typing.Any]\nfunction that takes SMILES string as input\n\n\nReturns\ntyping.Callable[[main.Molecule], typing.Any]\nfunction that takes Molecule as input\n\n\n\n\nsource\n\n\n\n\n mol_func_wrapper (func:Callable[[rdkit.Chem.rdchem.Mol],Any])\n\ntakes a function with a Chem.Mol input and returns a wrapped version that accepts a Molecule as input\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfunc\ntyping.Callable[[rdkit.Chem.rdchem.Mol], typing.Any]\nfunction that takes rdkit Mol as input\n\n\nReturns\ntyping.Callable[[main.Molecule], typing.Any]\nfunction that takes Molecule as input\n\n\n\n\nrdkit_function = rdMolDescriptors.CalcExactMolWt\n\nsmile = 'CCCCCC'\nmol = to_mol(smile)\nmolecule = Molecule(smile)\n\nwrapped_function = mol_func_wrapper(rdkit_function)\n\nassert rdkit_function(mol) == wrapped_function(molecule)\n\n\nsource\n\n\n\n\n Catalog (catalog:rdkit.Chem.rdfiltercatalog.FilterCatalog)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\nType\nDetails\n\n\n\n\ncatalog\nFilterCatalog\ninput filter catalog\n\n\n\n\nsmarts = [\n    '[*]-[#6]1:[#6]:[#6](-[#0]):[#6]:[#6](-[*]):[#6]:1',\n    '[*]-[#6]1:[#6]:[#6](-[*]):[#6]:[#6]:[#6]:1',\n    '[*]-[#6]1:[#6]:[#6]:[#6]:[#6]:[#6]:1',\n    '[*]-[#6]1:[#6]:[#6](-[#7]-[*]):[#6]:[#6]:[#6]:1',\n    '[#6]1:[#6]:[#7]:[#6]:[#6]:[#6]:1'\n]\n\ncatalog = Catalog.from_smarts(smarts)\n\nsmiles = [\n    'c1ccccc1',\n    'Cc1cccc(NCc2ccccc2)c1'\n]\n\nmolecules = [Molecule(i) for i in smiles]\n\nassert not catalog.has_match(molecules[0])\nassert catalog.has_match(molecules[1])"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "chem_templates",
    "section": "",
    "text": "chem_templates provides an expressive and flexible way of defining desired chemical spaces\nSee the documentation for documentation and tutorials"
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "chem_templates",
    "section": "Install",
    "text": "Install\npip install chem_templates"
  },
  {
    "objectID": "index.html#basic-usage",
    "href": "index.html#basic-usage",
    "title": "chem_templates",
    "section": "Basic Usage",
    "text": "Basic Usage\nFor more detail on the API, see the basic tutorial\nfrom rdkit.Chem import rdMolDescriptors, Descriptors\nfrom chem_templates.filter import RangeFunctionFilter, Template\nfrom chem_templates.chem import Molecule\n\ndef hbd(molecule):\n    return rdMolDescriptors.CalcNumHBD(molecule.mol)\n\ndef hba(molecule):\n    return rdMolDescriptors.CalcNumHBA(molecule.mol)\n\ndef molwt(molecule):\n    return rdMolDescriptors.CalcExactMolWt(molecule.mol)\n\ndef logp(molecule):\n    return Descriptors.MolLogP(molecule.mol)\n\nhbd_filter = RangeFunctionFilter(hbd, 'hydrogen_bond_donor', None, 5)\nhba_filter = RangeFunctionFilter(hba, 'hydrogen_bond_acceptor', None, 10)\nmolwt_filter = RangeFunctionFilter(molwt, 'mol_weight', None, 500)\nlogp_filter = RangeFunctionFilter(logp, 'logp', None, 5)\n\nfilters = [\n    hbd_filter,\n    hba_filter,\n    molwt_filter,\n    logp_filter\n]\n\nro5_template = Template(filters)\n\nsmiles = ['C=CCNC(=O)N1CCN(C(=O)[C@H]2C[C@@H]2c2cccc(F)c2F)CC1',\n 'C[C@@H]1CCCC[C@@H]1OCC(=O)OCc1nnc(-c2cccc(Br)c2)o1',\n 'CCC[C@@H](OC)C(=O)N[C@@H](CNc1cnc(F)cn1)C(C)C',\n 'CC(C)/C=C\\\\C(=O)N1CCC[C@@](CO)(NC(=O)OC(C)(C)C)C1',\n 'C(c1ccccc1)CCC[C@@H](C)c1nnc(N2CCN(C(=O)OC(C)(C)C)[C@@H](C)C2)n1Cc1csc(C(C)(C)C)n1',\n 'O=C(c1cccc(F)c1)N1CC[C@]2(CN(CC3=CCCCC3)CCO2)C1']\n\nmolecules = [Molecule(i) for i in smiles]\nresults = [ro5_template(i).result for i in molecules]\n&gt;[True, True, True, True, False, True]"
  },
  {
    "objectID": "tutorials/fragment_tutorial.html",
    "href": "tutorials/fragment_tutorial.html",
    "title": "Fragment Tutorial",
    "section": "",
    "text": "This tutorial shows how to use chem_templates fragment assembly to build highly targeted molecular libraries.\nWe can use a Template to define a series of pass/fail criteria for a single molecule, giving us control over chemical space. But what if we want more fine-grained control over the structure? What if we want molecules that conform to the pattern [R1]-[linker]-[scaffold], with a specific Template for each of those sections?\nThis is challenging from a top-down approach because it requires figuring out how to map arbitrary molecules to the [R1]-[linker]-[scaffold], which involves a dizzying amount of SMARTS definitions. A much easier way is to assemble molecules from the bottom up, ensuring that each fragment in the assembly matches the desired chemotype.\nWe can accomplish this with the following steps: 1. define templates 2. define assembly schema 3. create fragment library 4. assemble molecules"
  },
  {
    "objectID": "tutorials/fragment_tutorial.html#defining-templates",
    "href": "tutorials/fragment_tutorial.html#defining-templates",
    "title": "Fragment Tutorial",
    "section": "Defining Templates",
    "text": "Defining Templates\nFirst we need to define templates for our assembly schema. We want molecules to conform to [R1]-[linker]-[scaffold]. We will define separate templates for R1, linker, scaffold and the full assembled molecule:\nR1 template: * 1 ring * no rotatable bonds\nLinker template: * no rings * at most 4 rotatable bonds * at most 60 g/mol\nScaffold template: * 2 rings * at most 250 g/mol\nFull molecule template: * Valid compound * Single compound * &lt;= 8 rotatable bonds * &lt;=5 hydrogen bond donors * &lt;=10 hydrogen bond acceptors * &lt;= 500 g/mol * &lt;= 5 ClogP\n\nfrom chem_templates.chem import Molecule\nfrom chem_templates.fragments import shred_smiles\nfrom chem_templates.assembly import AssemblyInputs, FragmentNode, FragmentLeafNode\nfrom chem_templates.filter import RangeFunctionFilter, ValidityFilter, SingleCompoundFilter, Template\n\nfrom rdkit.Chem import rdMolDescriptors, Descriptors\nfrom rdkit.Chem import Draw\n\n\ndef rings(molecule):\n    return rdMolDescriptors.CalcNumRings(molecule.mol)\n\ndef hbd(molecule):\n    return rdMolDescriptors.CalcNumHBD(molecule.mol)\n\ndef hba(molecule):\n    return rdMolDescriptors.CalcNumHBA(molecule.mol)\n\ndef molwt(molecule):\n    return rdMolDescriptors.CalcExactMolWt(molecule.mol)\n\ndef logp(molecule):\n    return Descriptors.MolLogP(molecule.mol)\n\ndef rotb(molecule):\n    return rdMolDescriptors.CalcNumRotatableBonds(molecule.mol)\n\n\nr1_template = Template([\n    RangeFunctionFilter(rings, 'rings', 1, 1),\n    RangeFunctionFilter(rotb, 'rotatable_bonds', 0, 0)\n])\n\nlinker_template = Template([\n    RangeFunctionFilter(rings, 'rings', 0, 0),\n    RangeFunctionFilter(rotb, 'rotatable_bonds', None, 4),\n    RangeFunctionFilter(molwt, 'mol_wt', None, 60)\n])\n\nscaffold_template = Template([\n    RangeFunctionFilter(rings, 'rings', 2, 2),\n    RangeFunctionFilter(molwt, 'mol_wt', None, 250)\n])\n\nfull_template = Template([\n    ValidityFilter(),\n    SingleCompoundFilter(),\n    RangeFunctionFilter(rotb, 'rotatable_bonds', None, 8),\n    RangeFunctionFilter(hbd, 'hydrogen_bond_donors', None, 5),\n    RangeFunctionFilter(hba, 'hydrogen_bond_acceptors', None, 10),\n    RangeFunctionFilter(molwt, 'mol_wt', None, 500),\n    RangeFunctionFilter(logp, 'clogp', None, 5)\n])"
  },
  {
    "objectID": "tutorials/fragment_tutorial.html#define-assembly-schema",
    "href": "tutorials/fragment_tutorial.html#define-assembly-schema",
    "title": "Fragment Tutorial",
    "section": "Define Assembly Schema",
    "text": "Define Assembly Schema\nNow we define how the fragments will fit together. First we define our leaf nodes with the FragmentLeafNode class. Each leaf node is given a name, a set of mapping_idxs, and a template.\nThe mapping_idxs define how fragments are mapped and assembled. Mappings are implemented as an annotation on dummy atoms, ie [*:1]C would be a carbon atom with a single mapping with 1 as the mapping index.\nFor this schema, we will use the following mappings: * R1 - [1] * Linker - [1,2] * Scaffold - [2]\nThis tells us that all R1 fragments should have a single mapping with 1 as the index - ie [*:1][R1].\nLinker fragments should have two mappings with 1 and 2 as the index values - ie [*:1][linker][*:2]\nScaffold fragments should have one mapping with 2 as the index - ie [*:2][scaffold]\nThese will be assembled as [R1]-[*:1]-[linker]-[*:2]-[scaffold] -&gt; [R1]-[linker]-[scaffold]\n\nR1 = FragmentLeafNode('R1', [1], template=r1_template)\nlinker = FragmentLeafNode('L1', [1, 2], template=linker_template)\nscaffold = FragmentLeafNode('scaffold', [2], template=scaffold_template)\n\nNow we need to define how to assemble these fragments. We can do this with the FragmentNode class:\n\nfull_molecule = FragmentNode('full_molecule', [scaffold, R1, linker], template=full_template)\n\nThis will fuse our three leaf nodes into a single molecule. We can validate our assembly by checking the dummy_mol object of the full molecule node:\n\nDraw.MolToImage(full_molecule.dummy)\n\n\n\n\nWe used the most simple assembly:\nfull_molecule = FragmentNode('full_molecule', [scaffold, R1, linker], template=full_template)\nThis grabs our three leaf nodes and assembles them all at once.\nIf we wanted, we could use more intermediate nodes to give more control. Say we wanted to add another template check on [R1]-[linker], we could do that with another intermediate node:\nr1_linker_fused = FragmentNode('r1_linker_fused', [R1, linker], template=r1_fused_template)\nfull_molecule = FragmentNode('full_molecule', [scaffold, r1_linker_fused], template=full_template)\nOr we could have an intermediate node for [linker]-[scaffold]:\nlinker_scaffold_fused = FragmentNode('linker_scaffold_fused', [scaffold, linker], template=linker_scaffold_fused_template)\nfull_molecule = FragmentNode('full_molecule', [linker_scaffold_fused, R1], template=full_template)\nIn practice, you should add an intermediate node whenever you think another template would be useful"
  },
  {
    "objectID": "tutorials/fragment_tutorial.html#create-fragment-library",
    "href": "tutorials/fragment_tutorial.html#create-fragment-library",
    "title": "Fragment Tutorial",
    "section": "Create Fragment Library",
    "text": "Create Fragment Library\nNow we need some fragments. To make things easy, we’ll take a set list of SMILES and shred them to create fragments\n\nsmiles = ['CNc1nc(SCC(=O)Nc2cc(Cl)ccc2OC)nc2ccccc12',\n       'COc1ccc(C(=O)Oc2ccc(/C=C3\\\\C(=N)N4OC(C)=CC4=NC3=O)cc2OC)cc1',\n       'Cc1sc(NC(=O)c2ccccc2)c(C(N)=O)c1C',\n       'COc1ccc(NCc2noc(-c3ccoc3)n2)cc1OC(F)F',\n       'O=C(COC(=O)c1cccc(Br)c1)c1ccc2c(c1)OCCCO2',\n       'CCOC(=O)c1nc2ccccc2nc1N1CCN(c2ccc(OC)cc2)CC1',\n       'CC(=O)c1cc2c(N)c(C(=O)Nc3cccc4nsnc34)sc2nc1C',\n       'O=C(NCCc1csc(-c2ccccc2)n1)Nc1ccc2[nH]ccc2c1',\n       'CC(=O)c1ccc(NC(=O)Cn2c(=O)n(-c3ccc(F)cc3)c(=O)c3oc4ccccc4c32)cc1',\n       'O=C(NCCC[NH+]1Cc2ccccc2C1)c1cccc(Cn2cccn2)c1',\n       'O=C1CC(C(=O)Nc2ccc3c(c2)OCCO3)=c2ccccc2=[NH+]1',\n       'O=C(CSCc1ccc(F)cc1Cl)Nn1c(=S)[nH]c2sc3c(c2c1=O)CCC3',\n       'CN(CCS(C)(=O)=O)CC(=O)c1ccc2c(c1)CCC2',\n       'Cc1nn2ccccc2c1C(=O)N1CCN(C(=O)NC(C)C)CC1',\n       'CCN(CCO)c1ncnc(Nc2ccc(C)cc2C)c1N',\n       'O=C(COc1ccc(Cl)cc1Cl)Nc1ccc(S(=O)(=O)N2CCOCC2)cc1',\n       'COc1ccc(-c2ccc(=O)n(CCCC(=O)NC3CCCC3)n2)cc1',\n       'CCOc1cc(NC(=O)c2cccnc2Cl)ccc1OC',\n       'CCc1nn(C)cc1CNC(=O)CNC(=O)c1cccc([N+](=O)[O-])c1',\n       'Cc1ccc(CNC(=O)c2ccccc2NC(=O)c2ccc(NC(=O)C(C)C)cc2)cc1']\n\n\nfrags = shred_smiles(smiles, [1,2,3], 25, 4, False)\nlen(frags)\n\n0 20\n1 368\n2 45\n3 8\n\n\n437"
  },
  {
    "objectID": "tutorials/fragment_tutorial.html#assemble-molecules",
    "href": "tutorials/fragment_tutorial.html#assemble-molecules",
    "title": "Fragment Tutorial",
    "section": "Assemble Molecules",
    "text": "Assemble Molecules\nNow we do the assembly itself. First we run full_molecule.build_assembly_pools. This gives us a dictionary of AssemblyPool objects holding fragments that match the template for each leaf node.\nThen we create our AssemblyInputs and pass them to full_molecule.assemble. The result is a pool of molecules that all conform to our [R1]-[linker]-[scaffold] chemotype and match each template we created above\n\nfrag_molecules = [Molecule(i) for i in frags]\n\n\nassembly_dict = full_molecule.build_assembly_pools(frag_molecules)\nassembly_dict\n\n{'L1': AssemblyPool: 41 items,\n 'R1': AssemblyPool: 11 items,\n 'scaffold': AssemblyPool: 33 items}\n\n\n\nassembly_inputs = AssemblyInputs(assembly_dict, 1000, 5000)\n\n\nassembled = full_molecule.assemble(assembly_inputs)\nassembled\n\nscaffold\nR1\nL1\nfull_molecule\n\n\nAssemblyPool: 5659 items\n\n\n\nDraw.MolToImage(assembled[0].mol)"
  },
  {
    "objectID": "tutorials/template_tutorial.html",
    "href": "tutorials/template_tutorial.html",
    "title": "Template Tutorial",
    "section": "",
    "text": "from chem_templates.filter import RangeFunctionFilter, SmartsFilter, CatalogFilter, \\\nBinaryFunctionFilter, DataFunctionFilter, Template\nfrom chem_templates.chem import Molecule, Catalog\n\nfrom rdkit import Chem\nfrom rdkit.Chem import rdMolDescriptors, Descriptors\nfrom rdkit.Chem.FilterCatalog import FilterCatalogParams\nA fundamental step in computational drug design is defining what molecules we want. If we don’t have a sense of what molecules are in-spec for a specific project, we risk wasting significant effort screening irrelevant or flawed compounds.\nThe chem_templates library enables defining expressive and detailed chemical spaces by defining a Template made from various Filter screens"
  },
  {
    "objectID": "tutorials/template_tutorial.html#filters",
    "href": "tutorials/template_tutorial.html#filters",
    "title": "Template Tutorial",
    "section": "Filters",
    "text": "Filters\nThe Filter class lets us define pass/fail requirements for a molecule. A filter can be made from any function or evaluation that takes in a Molecule object and returns a True/False result.\nThe most common type of filter used is RangeFunctionFilter. This uses some function that maps a Molecule to a numeric value, and checks to see if the value is within some range. The example below filters molecules based on the number of rings present:\n\ndef num_rings(molecule):\n    return rdMolDescriptors.CalcNumRings(molecule.mol)\n    \nfilter_name = 'rings' # filter name \nmin_val = 1 # minimum number of rings (inclusive)\nmax_val = 2 # maximum number of rings (inclusive)\nring_filter = RangeFunctionFilter(num_rings, filter_name, min_val, max_val)\n\nno_rings = Molecule('CCCC')\none_ring = Molecule('c1ccccc1')\ntwo_rings = Molecule('c1ccc(Cc2ccccc2)cc1')\nthree_rings = Molecule('c1ccc(Cc2ccccc2Cc2ccccc2)cc1')\n\nresults = [\n    ring_filter(no_rings),\n    ring_filter(one_ring),\n    ring_filter(two_rings),\n    ring_filter(three_rings)\n]\n\n[i.filter_result for i in results]\n\n[False, True, True, False]\n\n\nResults are returned in the form of the FilterResult which holds the aggregate boolean result (True/False pass/fail), the name of the filter, and any data added by the filter.\nThe RangeFunctionFilter automatically adds data on the value computed by the function, as well as the min/max values for the range\n\nres = results[0]\nprint(res.filter_result, res.filter_name, res.filter_data)\n\nFalse rings {'computed_value': 0, 'min_val': 1, 'max_val': 2}\n\n\nWe can also filter with SMARTS string substructure match using SmartsFilter\n\nsmarts_string = '[#6]1:[#6]:[#6]:[#7]:[#6]:[#6]:1' # filter for pyridine ring\nname = 'pyridine'\nexclude = True # exclude matches\nmin_val = 1 # min number of matches to trigger filter\nmax_val = None # max number of matches to trigger filter (None resolves to any value above min_val)\n\nsmarts_filter = SmartsFilter(smarts_string, name, exclude, min_val, max_val)\n\nbenzene = Molecule('c1ccccc1')\npyridine = Molecule('c1cnccc1')\ntwo_nitrogen = Molecule('c1cnncc1')\n\nresults = [\n    smarts_filter(benzene),\n    smarts_filter(pyridine),\n    smarts_filter(two_nitrogen)\n]\n\n[i.filter_result for i in results]\n\n[True, False, True]\n\n\nThe CatalogFilter class lets us filter on rdkit catalogs. The example below filters on the PAINS catalog:\n\ncatalog = Catalog.from_params(FilterCatalogParams.FilterCatalogs.PAINS)\npains_filter = CatalogFilter(catalog, 'pains')\n\npains_passing = Molecule('c1ccccc1Nc1ccccc1')\npains_failing = Molecule('c1ccccc1N=Nc1ccccc1')\n\nresults = [\n    pains_filter(pains_passing),\n    pains_filter(pains_failing)\n]\n\n[i.filter_result for i in results]\n\n[True, False]"
  },
  {
    "objectID": "tutorials/template_tutorial.html#custom-filters",
    "href": "tutorials/template_tutorial.html#custom-filters",
    "title": "Template Tutorial",
    "section": "Custom Filters",
    "text": "Custom Filters\nTo allow for flexibility, the BinaryFunctionFilter and DataFunctionFilter allow us to make filters from arbitrary functions.\nThe BinaryFunctionFilter class works with any function that maps a Molecule to a boolean value:\n\ndef my_func(molecule):\n    if rdMolDescriptors.CalcExactMolWt(molecule.mol) &gt; 150 and Chem.QED.qed(molecule.mol) &gt; 0.6:\n        return True\n    else:\n        return False\n    \nmy_filter = BinaryFunctionFilter(my_func, 'molwt_plus_qed')\n\nprint(my_filter(Molecule('c1ccc(Cc2ccccc2)cc1')).filter_result)\n\nTrue\n\n\nIf we want more information about what the filter function has computed, we can use the BinaryFunctionFilter class. This works in the same way, but expects the filter function to also return a dictionary of values\n\ndef my_func(molecule):\n    molwt = rdMolDescriptors.CalcExactMolWt(molecule.mol)\n    qed = Chem.QED.qed(molecule.mol)\n    \n    data_dict = {'molwt' : molwt, 'qed' : qed}\n    \n    if molwt &gt; 150 and qed &gt; 0.6:\n        return True, data_dict\n    else:\n        return False, data_dict\n    \nmy_filter = DataFunctionFilter(my_func, 'molwt_plus_qed')\n\nresult = my_filter(Molecule('c1ccc(Cc2ccccc2)cc1'))\n\nprint(result.filter_result, result.filter_data)\n\nTrue {'molwt': 168.093900384, 'qed': 0.6452001853099995}"
  },
  {
    "objectID": "tutorials/template_tutorial.html#templates",
    "href": "tutorials/template_tutorial.html#templates",
    "title": "Template Tutorial",
    "section": "Templates",
    "text": "Templates\nThe Template class holds multiple filters and executes them together. Below is an example of implementing the Rule of Five with a template:\n\ndef hbd(molecule):\n    return rdMolDescriptors.CalcNumHBD(molecule.mol)\n\ndef hba(molecule):\n    return rdMolDescriptors.CalcNumHBA(molecule.mol)\n\ndef molwt(molecule):\n    return rdMolDescriptors.CalcExactMolWt(molecule.mol)\n\ndef logp(molecule):\n    return Descriptors.MolLogP(molecule.mol)\n\nhbd_filter = RangeFunctionFilter(hbd, 'hydrogen_bond_donor', None, 5)\nhba_filter = RangeFunctionFilter(hba, 'hydrogen_bond_acceptor', None, 10)\nmolwt_filter = RangeFunctionFilter(molwt, 'mol_weight', None, 500)\nlogp_filter = RangeFunctionFilter(logp, 'logp', None, 5)\n\nfilters = [\n    hbd_filter,\n    hba_filter,\n    molwt_filter,\n    logp_filter\n]\n\nro5_template = Template(filters)\n\nmolecule = Molecule('CC1=CN=C(C(=C1OC)C)CS(=O)C2=NC3=C(N2)C=C(C=C3)OC')\nresult = ro5_template(molecule)\n\nTemplate results are returned as a TemplateResult, which holds the overall True/False result, as well as results and data from individual filters\n\nprint(result.result)\nprint(result.filter_results)\nprint(result.filter_data)\n\nTrue\n[True, True, True, True]\n[hydrogen_bond_donor result: True, hydrogen_bond_acceptor result: True, mol_weight result: True, logp result: True]"
  },
  {
    "objectID": "tutorials/template_tutorial.html#suggested-template-usage",
    "href": "tutorials/template_tutorial.html#suggested-template-usage",
    "title": "Template Tutorial",
    "section": "Suggested Template Usage",
    "text": "Suggested Template Usage\nThe following are suggestions for getting the most out of chemical templates:\n\nLeverage Cheap Filters\nA major advantage of using filters/templates at scale is the cost per filter per molecule is generally low. Computing the molecular weight or number of rings in a compound is significantly cheaper compared to virtual screening methods such as predictive models or docking. Filters can be used to cheaply eliminate “out of spec” molecules before passing “in spec” molecules to more sophisticated screening methods.\n\n\nMaintain Desired Chemotypes\nIf a drug project has a desired chemotype or chemotypes, we want to eliminate molecules that don’t match the desired chemotype(s). We can define the chemotype using SMARTS strings, and use SmartsFilter with exclude=False to eliminate molecules that don’t match the chemotype SMARTS.\n\n\nControl IP Space\nIf you wish to avoid pre-existing IP, you can specify infringing chemotypes with SMARTS strings and use SmartsFilter with exclude=True to eliminate possibly infringing molecules\n\n\nSynthetic Accessibility\nSynthetic accessibility is a major factor in designing novel compounds. Given that synthesis bandwidth is typically a bottleneck in discovery pipelines, we want to avoid difficult to synthesize compounds that drain lab resources from other compounds. This challenge is often approached in literature using SA Score.\nUnfortunately, SA score is often a poor fit for real discovery projects. SA score basically computes properties related to size, stereocenters, spiro-carbons, bridge-head carbons, and macrocycles, and renders those values into an aggregate score. While the SA score evaluation is generally reasonable from a “synthesize from scratch” perspective, it doesn’t capture the reality in the lab. For example, plenty of compounds with terrible SA scores can be easily created by taking advantage of building blocks that contain difficult structures.\nSA score fails to capture the question of “how hard is it for my specific lab team to make this compound”. A better approach is to work with the lab team to define what compounds/substructures are hard to synthesize and develop a set of custom “SA score” filters based on this information."
  },
  {
    "objectID": "building_blocks.html",
    "href": "building_blocks.html",
    "title": "Building Blocks",
    "section": "",
    "text": "source\n\nsmile_to_synthon\n\n smile_to_synthon (smile:str, keep_pg:bool=False)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsmile\nstr\n\nsmiles string to convert\n\n\nkeep_pg\nbool\nFalse\nif True, results include synthons with un-removed protecting groups\n\n\nReturns\nTuple[list[str], list[list[str]]]\n\nReturns paired list of SMILES and reaction classes\n\n\n\n\nassert smile_to_synthon('COC(=O)c1ccnc(CNC(=O)NCC2(C)CC(N=C=O)CC(C)(C)C2)c1')[0] == [\n    'CC1(C)CC(N[CH:10]=O)CC(C)(CNC(=O)NCc2cc(C(=O)O)ccn2)C1',\n    'CC1(C)CC(N[CH:10]=O)CC(C)(CNC(=O)NCc2cc([CH:10]=O)ccn2)C1']\n\n\nsource\n\n\nget_synthon_marks\n\n get_synthon_marks (smile:str)\n\nextracts reaction tag marks from synthon\nie 'CC1(C)CC(N[CH:10]=O)CC(C)(CNC(=O)NCc2cc([CH:10]=O)ccn2)C1' -&gt; ['C:10']\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\ninput synthon smiles string\n\n\nReturns\nlist[str]\nlist of marks\n\n\n\n\nassert get_synthon_marks('CC1(C)CC(N[CH:10]=O)CC(C)(CNC(=O)NCc2cc([CH:10]=O)ccn2)C1') == ['C:10']\n\n\nsource\n\n\nremove_reconstruction_atoms\n\n remove_reconstruction_atoms (smile:str)\n\nremoves dummy atoms for fusion\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\nsynthon reconstruction string\n\n\nReturns\nstr\nsynthon smiles string\n\n\n\n\nsource\n\n\nadd_reconstruction_atoms\n\n add_reconstruction_atoms (smile:str)\n\naugments synthon annotations (ie c:10) with dummy atoms for fusion\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\nsynthon smiles string\n\n\nReturns\nstr\nsynthon reconstruction string\n\n\n\n\nassert add_reconstruction_atoms('CC1(C)CC(N[CH:10]=O)CC(C)(CNC(=O)NCc2cc([CH:10]=O)ccn2)C1'\n                        ) == 'CC1(C)CC(N[C:10](=O)[V])CC(C)(CNC(=O)NCc2cc([C:10](=O)[V])ccn2)C1'\n\nassert remove_reconstruction_atoms('CC1(C)CC(N[C:10](=O)[V])CC(C)(CNC(=O)NCc2cc([C:10](=O)[V])ccn2)C1'\n                           ) == 'CC1(C)CC(N[CH:10]=O)CC(C)(CNC(=O)NCc2cc([CH:10]=O)ccn2)C1'\n\nassert remove_reconstruction_atoms(add_reconstruction_atoms(\n    'CC1(C)CC(N[CH:10]=O)CC(C)(CNC(=O)NCc2cc([CH:10]=O)ccn2)C1'\n    )) == 'CC1(C)CC(N[CH:10]=O)CC(C)(CNC(=O)NCc2cc([CH:10]=O)ccn2)C1'\n\n\nsource\n\n\nSynthon\n\n Synthon (synthon_smile:str, reaction_tags:list[str]=None,\n          parents:Optional[list[Molecule]]=None, data:Optional[dict]=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsynthon_smile\nstr\n\nsynthon smiles string\n\n\nreaction_tags\nlist[str]\nNone\nreaction class tags\n\n\nparents\nOptional[list[Molecule]]\nNone\nparent molecule\n\n\ndata\nOptional[dict]\nNone\ndata\n\n\n\n\nsource\n\n\nmolecule_to_synthon\n\n molecule_to_synthon (molecule:chem_templates.chem.Molecule)\n\nConverts molecule into a list of corresponding synthons\n\n\n\n\nType\nDetails\n\n\n\n\nmolecule\nMolecule\ninput Molecule\n\n\nReturns\nlistSynthon\noutput list of synthons\n\n\n\n\nmolecule = Molecule('COC(=O)c1ccnc(CNC(=O)NCC2(C)CC(N=C=O)CC(C)(C)C2)c1')\nsynthons = molecule_to_synthon(molecule)\nassert len(synthons)==2\nassert synthons[0].data['parents'] == [molecule]\nassert synthons[0].data['parents'] == synthons[1].data['parents']\nassert synthons[0].recon_smile == 'CC1(C)CC(N[C:10](=O)[V])CC(C)(CNC(=O)NCc2cc(C(=O)O)ccn2)C1'\n\n\nsource\n\n\nFusionReaction\n\n FusionReaction (name:str, rxn_smarts:str)\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\nType\nDetails\n\n\n\n\nname\nstr\nreaction name\n\n\nrxn_smarts\nstr\nreaction smarts\n\n\n\n\nsource\n\n\nReactionGroup\n\n ReactionGroup (name:str, reactions:list[FusionReaction])\n\nholds reactions beloning to the same type of transform\n\n\n\n\nType\nDetails\n\n\n\n\nname\nstr\ngroup name\n\n\nreactions\nlistFusionReaction\nlist of reactions in group\n\n\n\n\nsource\n\n\nReactionUniverse\n\n ReactionUniverse (name:str, reaction_groups:list[ReactionGroup])\n\nInitialize self. See help(type(self)) for accurate signature.\n\n\n\n\nType\nDetails\n\n\n\n\nname\nstr\nrxn universe name\n\n\nreaction_groups\nlistReactionGroup\nlist of reaction groups\n\n\n\n\nrxn_universe = ReactionUniverse('all_reactions', REACTION_GROUPS)\nmolecule = Molecule('COC(=O)c1ccnc(CNC(=O)NCC2(C)CC(N=C=O)CC(C)(C)C2)c1')\nsynthons = molecule_to_synthon(molecule)\nassert len(rxn_universe.get_matching_reactions(synthons[0])) == 9"
  },
  {
    "objectID": "assembly.html",
    "href": "assembly.html",
    "title": "Assembly",
    "section": "",
    "text": "source\n\nAssemblyPool\n\n AssemblyPool (items:list[Molecule])\n\nInitialize self. See help(type(self)) for accurate signature.\n\npool = AssemblyPool([Molecule('C'), Molecule('CCCCC')])\nassert len(pool)==2\ndef filter_func(molecule):\n    return len(molecule.smile)&gt;1\n\npool2 = pool.filter(filter_func)\nassert len(pool2)==1\n\npool = AssemblyPool([Molecule('C'), Molecule('C'), Molecule('C')])\npool = pool.deduplicate(lambda x: x.smile)\nassert len(pool)==1\n\n\nsource\n\n\nAssemblyInputs\n\n AssemblyInputs (pool_dict:dict[str,AssemblyPool], assembly_chunksize:int,\n                 max_assemblies_per_node:int,\n                 worker_pool:Optional[Pool]=None, log:bool=True)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nNode\n\n Node (name:str, template:Optional[Template]=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nFragmentNode\n\n FragmentNode (name:str, children:list[FragmentNode],\n               template:Optional[Template]=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nFragmentLeafNode\n\n FragmentLeafNode (name:str, mapping_idxs:list[int],\n                   template:Optional[Template]=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nf1 = ['[*:1]C', '[*:1]N', '[*:2]O']\nf2 = ['[*:1]CC', '[*:1]CCC']\n\nm1 = [Molecule(i) for i in f1]\nm2 = [Molecule(i) for i in f2]\n\np1 = AssemblyPool(m1)\np2 = AssemblyPool(m2)\n\nassembly_dict = {\n    'R1' : p1,\n    'R2' : p2\n}\n\nassembly_inputs = AssemblyInputs(assembly_dict, 10000, 1e8)\n\nr1 = FragmentLeafNode('R1', [1])\nr2 = FragmentLeafNode('R2', [1])\nfull = FragmentNode('F', [r1, r2])\n\nout = full.assemble(assembly_inputs)\n\nassert len(out)==4\nprint(json.dumps(full.dump(), indent=1))\n\n{\n \"name\": \"F\",\n \"node_type\": \"fragment_node\",\n \"template\": null,\n \"children\": [\n  {\n   \"name\": \"R1\",\n   \"node_type\": \"fragment_leaf_node\",\n   \"mapping_idxs\": [\n    1\n   ],\n   \"template\": null\n  },\n  {\n   \"name\": \"R2\",\n   \"node_type\": \"fragment_leaf_node\",\n   \"mapping_idxs\": [\n    1\n   ],\n   \"template\": null\n  }\n ]\n}\n\n\n\nsource\n\n\nSynthonPool\n\n SynthonPool (items:list[Synthon])\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nmake_assemblies\n\n make_assemblies (pool1:__main__.SynthonPool, pool2:__main__.SynthonPool,\n                  rxn_universe:chem_templates.building_blocks.ReactionUniv\n                  erse, chunksize:int, worker_pool:Optional[&lt;boundmethodBa\n                  seContext.Poolof&lt;multiprocessing.context.DefaultContexto\n                  bjectat0x7fce59bc5130&gt;&gt;]=None)\n\n\nsource\n\n\nadd_rxn\n\n add_rxn (pair:Tuple[chem_templates.building_blocks.Synthon,chem_templates\n          .building_blocks.Synthon],\n          rxn_universe:chem_templates.building_blocks.ReactionUniverse)\n\n\nsource\n\n\nmake_pairs_chunked\n\n make_pairs_chunked (pool1:__main__.SynthonPool,\n                     pool2:__main__.SynthonPool, chunksize:int)\n\n\nsource\n\n\nmake_pairs\n\n make_pairs (pool1:__main__.SynthonPool, pool2:__main__.SynthonPool)\n\n\nsource\n\n\nSynthonNode\n\n SynthonNode (name:str, incoming_node:SynthonNode, next_node:SynthonNode,\n              rxn_universe:ReactionUniverse, n_func:set[int],\n              template:Optional[Template]=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nSynthonLeafNode\n\n SynthonLeafNode (name:str, n_func:set[int],\n                  template:Optional[Template]=None)\n\nInitialize self. See help(type(self)) for accurate signature.\n\np1 = SynthonPool([Synthon('O=C(O)CCN[CH:10]=O'), Synthon('O=C(O)CCCN[CH:10]=O')])\np2 = SynthonPool([Synthon('CCOC(=O)c1c([NH2:20])sc2c1CCNC2'), Synthon('C1CN(C2CC[NH:20]C2)CCN1')])\nrxn_universe = ReactionUniverse('all_rxns', REACTION_GROUPS)\n\nbb1 = SynthonLeafNode('bb1', set([1]))\nbb2 = SynthonLeafNode('bb2', set([1]))\nprod = SynthonNode('product', bb1, bb2, rxn_universe, set([0]))\n\ninput_dict = {\n    'bb1' : p1,\n    'bb2' : p2\n}\n\ninputs = AssemblyInputs(input_dict, 10000, 10000)\n\noutputs = prod.assemble(inputs, verbose=True)\nassert len(outputs) == 4\n\nprod.dump()\n\nbb1\nbb2\nproduct\n\n\n{'name': 'product',\n 'node_type': 'synthon_node',\n 'n_func': {0},\n 'template': None,\n 'rxn_universe': &lt;chem_templates.building_blocks.ReactionUniverse&gt;,\n 'incoming_node': {'name': 'bb1',\n  'node_type': 'synthon_leaf_node',\n  'n_func': {1},\n  'template': None},\n 'next_node': {'name': 'bb2',\n  'node_type': 'synthon_leaf_node',\n  'n_func': {1},\n  'template': None}}\n\n\n\nsource\n\n\nbuild_synthesis_scheme\n\n build_synthesis_scheme (synthon:chem_templates.building_blocks.Synthon)\n\n\nbb1 = SynthonLeafNode('bb1', set([1]))\nbb2 = SynthonLeafNode('bb2', set([2]))\nprod1 = SynthonNode('product1', bb1, bb2, rxn_universe, set([1]))\nbb3 = SynthonLeafNode('bb3', set([1]))\nprod2 = SynthonNode('product2', prod1, bb3, rxn_universe, set([0]))\n\nmol1 = Molecule('Nc1cc(O)c(Br)cc1Br', {'ID' : 'EN300-104251'})\nmol2 = Molecule('CCOC(=O)c1c(C)[nH]c(C(=O)C(C)Cl)c1C', {'ID' : 'EN300-08472'})\nmol3 = Molecule('O=C(O)C1(Cc2ccc(Br)cc2F)CCCNC1', {'ID' : 'EN300-6745292'})\n\np1 = SynthonPool(molecule_to_synthon(mol1))\np2 = SynthonPool(molecule_to_synthon(mol2))\np3 = SynthonPool(molecule_to_synthon(mol3))\n\ninput_dict = {\n    'bb1' : p1,\n    'bb2' : p2,\n    'bb3' : p3\n}\n\ninputs = AssemblyInputs(input_dict, 10000, 10000)\n\noutputs = prod2.assemble(inputs, verbose=False)\n\nprint(json.dumps(build_synthesis_scheme(outputs[0]), indent=2))\n\n{\n  \"result\": \"CCOC(=O)c1c(C)c(C(=O)C(C)Oc2cc(N)c(Br)cc2Br)n(C(=O)C2(Cc3ccc(Br)cc3F)CCCNC2)c1C\",\n  \"is_input\": false,\n  \"assembly_data\": {\n    \"parents\": [\n      {\n        \"result\": \"CCOC(=O)c1c(C)c(C(=O)C(C)Oc2cc(N)c(Br)cc2Br)[nH:20]c1C\",\n        \"is_input\": false,\n        \"assembly_data\": {\n          \"parents\": [\n            {\n              \"input\": \"Nc1cc(O)c(Br)cc1Br\",\n              \"is_input\": true,\n              \"data\": {\n                \"ID\": \"EN300-104251\"\n              }\n            },\n            {\n              \"input\": \"CCOC(=O)c1c(C)[nH]c(C(=O)C(C)Cl)c1C\",\n              \"is_input\": true,\n              \"data\": {\n                \"ID\": \"EN300-08472\"\n              }\n            }\n          ],\n          \"reaction_tags\": [\n            \"O-SN alkylation\"\n          ]\n        }\n      },\n      {\n        \"input\": \"O=C(O)C1(Cc2ccc(Br)cc2F)CCCNC1\",\n        \"is_input\": true,\n        \"data\": {\n          \"ID\": \"EN300-6745292\"\n        }\n      }\n    ],\n    \"reaction_tags\": [\n      \"nH-Cu-mediated C-N coupling\"\n    ]\n  }\n}\n\n\n\nsource\n\n\nbuild_fragment_assembly_scheme\n\n build_fragment_assembly_scheme (molecule:chem_templates.chem.Molecule)\n\n\nf1 = ['[*:1]C', '[*:1]N', '[*:2]O']\nf2 = ['[*:1]CC', '[*:1]CCC']\n\nm1 = [Molecule(i, data={'test1':'test1'}) for i in f1]\nm2 = [Molecule(i, data={'test2':'test2'}) for i in f2]\n\np1 = AssemblyPool(m1)\np2 = AssemblyPool(m2)\n\nassembly_dict = {\n    'R1' : p1,\n    'R2' : p2\n}\n\nassembly_inputs = AssemblyInputs(assembly_dict, 10000, 1e8)\n\nr1 = FragmentLeafNode('R1', [1])\nr2 = FragmentLeafNode('R2', [1])\nfull = FragmentNode('F', [r1, r2])\n\noutputs = full.assemble(assembly_inputs)\n\nprint(json.dumps(build_fragment_assembly_scheme(outputs[0]), indent=2))\n\n{\n  \"result\": \"CCC\",\n  \"is_input\": false,\n  \"assembly_data\": {\n    \"parents\": [\n      {\n        \"input\": \"C[*:1]\",\n        \"is_input\": true,\n        \"data\": {\n          \"test1\": \"test1\"\n        }\n      },\n      {\n        \"input\": \"CC[*:1]\",\n        \"is_input\": true,\n        \"data\": {\n          \"test2\": \"test2\"\n        }\n      }\n    ],\n    \"input_smiles\": \"C[*:1].CC[*:1]\"\n  }\n}\n\n\n\nsource\n\n\nbuild_assembly_from_dict\n\n build_assembly_from_dict (assembly_schema:dict)\n\n\nschema1 = {\n \"name\": \"F\",\n \"node_type\": \"fragment_node\",\n \"template\": None,\n \"children\": [\n  {\n   \"name\": \"R1\",\n   \"node_type\": \"fragment_leaf_node\",\n   \"mapping_idxs\": [1],\n   \"template\": None\n  },\n  {\n   \"name\": \"R2\",\n   \"node_type\": \"fragment_leaf_node\",\n   \"mapping_idxs\": [1],\n   \"template\": None\n  }\n ]\n}\n\nassembly_schema = build_assembly_from_dict(schema1)\n\nschema2 = {'name': 'product',\n 'node_type': 'synthon_node',\n 'n_func': {0},\n 'template': None,\n 'rxn_universe': ReactionUniverse('all_rxns', REACTION_GROUPS),\n 'incoming_node': {'name': 'bb1',\n  'node_type': 'synthon_leaf_node',\n  'n_func': {1},\n  'template': None},\n 'next_node': {'name': 'bb2',\n  'node_type': 'synthon_leaf_node',\n  'n_func': {1},\n  'template': None}}\n\nassembly_schema = build_assembly_from_dict(schema2)"
  },
  {
    "objectID": "filters.html",
    "href": "filters.html",
    "title": "Filters",
    "section": "",
    "text": "source\n\nFilter\n\n Filter (name='filter')\n\nFilter base class\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\nfilter\nfilter name\n\n\n\n\nsource\n\n\nFilterResult\n\n FilterResult (filter_result:bool, filter_name:str, filter_data:dict)\n\nContainer for filter results\n\n\n\n\nType\nDetails\n\n\n\n\nfilter_result\nbool\noverall filter result (True or False)\n\n\nfilter_name\nstr\nname of filter\n\n\nfilter_data\ndict\nfilter data dict\n\n\n\n\nsource\n\n\nSingleCompoundFilter\n\n SingleCompoundFilter ()\n\nChecks if molecule is a single compound\n\nsource\n\n\nValidityFilter\n\n ValidityFilter ()\n\nChecks if molecule is valid\n\nmol1 = Molecule('CCCC')\nmol2 = Molecule('CCCc')\nmol3 = Molecule('CCC.CCCC')\n\nf1 = ValidityFilter()\nf2 = SingleCompoundFilter()\n\nassert f1(mol1).filter_result\nassert not f1(mol2).filter_result\nassert f1(mol3).filter_result\n\nassert f2(mol1).filter_result\nassert not f2(mol3).filter_result\n\n\nsource\n\n\nAttachmentCountFilter\n\n AttachmentCountFilter (num_attachments:int)\n\nChecks number of dummy attachment atoms\n\nmol1 = Molecule('[*:1]CC')\nmol2 = Molecule('[*:1]CC[*:2]')\nf = AttachmentCountFilter(1)\n\nassert f(mol1).filter_result\nassert not f(mol2).filter_result\n\n\nsource\n\n\nDataFunctionFilter\n\n DataFunctionFilter\n                     (func:Callable[[chem_templates.chem.Molecule],Tuple[b\n                     ool,dict]], name:str)\n\nFilter base class\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfunc\ntyping.Callable[[chem_templates.chem.Molecule], typing.Tuple[bool, dict]]\ncallable that takes a Molecule and returns (bool, dict)\n\n\nname\nstr\nfilter name\n\n\n\n\nsource\n\n\nBinaryFunctionFilter\n\n BinaryFunctionFilter (func:Callable[[chem_templates.chem.Molecule],bool],\n                       name:str)\n\nFilter base class\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nfunc\ntyping.Callable[[chem_templates.chem.Molecule], bool]\ncallable function that takes a Molecule as input and returns a bool\n\n\nname\nstr\nfilter name\n\n\n\n\nfrom rdkit.Chem import rdMolDescriptors\nmol1 = Molecule('Cc1nnc2n1-c1ccc(Cl)cc1C(c1ccccc1)=NC2')\nmol2 = Molecule('CCCC')\n\ndef filter_func(molecule):\n    n_rings = rdMolDescriptors.CalcNumRings(molecule.mol)\n    return n_rings&gt;1\n\nf = BinaryFunctionFilter(filter_func, 'has_ring')\n\nassert f(mol1).filter_result\nassert not f(mol2).filter_result\n\n\nsource\n\n\nRangeFunctionFilter\n\n RangeFunctionFilter\n                      (func:Callable[[chem_templates.chem.Molecule],Union[\n                      int,float]], name:str,\n                      min_val:Union[int,float,NoneType]=None,\n                      max_val:Union[int,float,NoneType]=None)\n\nFilter base class\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfunc\ntyping.Callable[[chem_templates.chem.Molecule], typing.Union[int, float]]\n\ncallable function, takes a Molecule as input, returns a numeric value\n\n\nname\nstr\n\nfilter name\n\n\nmin_val\ntyping.Union[int, float, NoneType]\nNone\nmin acceptable range value (if None, defaults to -inf)\n\n\nmax_val\ntyping.Union[int, float, NoneType]\nNone\nmax acceptable range value (if None, defaults to inf)\n\n\n\n\nfrom rdkit.Chem import rdMolDescriptors\n\nmolwt = mol_func_wrapper(rdMolDescriptors.CalcExactMolWt)\n\nf = RangeFunctionFilter(molwt, 'molwt_filter', 250, 350)\n\n\nmol1 = Molecule('Cc1nnc2n1-c1ccc(Cl)cc1C(c1ccccc1)=NC2')\nmol2 = Molecule('CCCC')\n\nassert f(mol1).filter_result\nassert not f(mol2).filter_result\n\n\nsource\n\n\nSmartsFilter\n\n SmartsFilter (smarts:str, name:str, exclude:bool=True,\n               min_val:Union[int,float,NoneType]=None,\n               max_val:Union[int,float,NoneType]=None)\n\nFilter base class\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsmarts\nstr\n\nSMARTS string\n\n\nname\nstr\n\nfilter name\n\n\nexclude\nbool\nTrue\nif filter should be exclusion or inclusion\n\n\nmin_val\ntyping.Union[int, float, NoneType]\nNone\nmin number of occurences\n\n\nmax_val\ntyping.Union[int, float, NoneType]\nNone\nmax number of occurences\n\n\n\n\nsmarts = '[#6]1:[#6]:[#6]:[#6]:[#6]:[#6]:1'\n\nf1 = SmartsFilter(smarts, 'one_phenyl', min_val=1, max_val=1)\nf2 = SmartsFilter(smarts, 'two_phenyl', min_val=2)\n\nsmiles = [\n    'c1ccccc1',\n    'Cc1cc(NC)cnc1',\n    'Cc1cccc(NCc2ccccc2)c1'\n]\n\nmolecules = [Molecule(i) for i in smiles]\n\nassert f1.has_match(molecules[0])\nassert not f1.has_match(molecules[1])\nassert not f1.has_match(molecules[2])\n\nassert not f2.has_match(molecules[0])\nassert not f2.has_match(molecules[1])\nassert f2.has_match(molecules[2])\n\n\nsource\n\n\nSimpleSmartsFilter\n\n SimpleSmartsFilter (smarts:str, name:str,\n                     min_val:Union[int,float,NoneType]=None,\n                     max_val:Union[int,float,NoneType]=None)\n\nFilter base class\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsmarts\nstr\n\nSMARTS string\n\n\nname\nstr\n\nfilter name\n\n\nmin_val\ntyping.Union[int, float, NoneType]\nNone\nmin number of occurences\n\n\nmax_val\ntyping.Union[int, float, NoneType]\nNone\nmax number of occurences\n\n\n\n\nsmarts = '[#6]1:[#6]:[#6]:[#6]:[#6]:[#6]:1'\n\nf1 = SimpleSmartsFilter(smarts, 'one_phenyl', min_val=1, max_val=1)\nf2 = SimpleSmartsFilter(smarts, 'two_phenyl', min_val=2)\nf3 = SimpleSmartsFilter(smarts, 'zero_phenyl', max_val=0)\n\nsmiles = [\n    'c1ccccc1',\n    'Cc1cc(NC)cnc1',\n    'Cc1cccc(NCc2ccccc2)c1'\n]\n\nmolecules = [Molecule(i) for i in smiles]\n\nassert f1(molecules[0]).filter_result\nassert not f2(molecules[0]).filter_result\nassert not f3(molecules[0]).filter_result\n\nassert not f1(molecules[1]).filter_result\nassert not f2(molecules[1]).filter_result\nassert f3(molecules[1]).filter_result\n\nassert not f1(molecules[2]).filter_result\nassert f2(molecules[2]).filter_result\nassert not f3(molecules[2]).filter_result\n\n\nsource\n\n\nCatalogFilter\n\n CatalogFilter (catalog:chem_templates.chem.Catalog, name:str,\n                exclude:bool=True)\n\nFilter base class\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ncatalog\nCatalog\n\nSMARTS catalog\n\n\nname\nstr\n\nfilter name\n\n\nexclude\nbool\nTrue\nif filter should be exclusion or inclusion\n\n\n\n\nfrom rdkit.Chem.FilterCatalog import FilterCatalogParams\n\ncatalog = Catalog.from_params(FilterCatalogParams.FilterCatalogs.PAINS)\nf = CatalogFilter(catalog, 'pains')\nmolecule = Molecule('c1ccccc1N=Nc1ccccc1')\n\nassert f.has_match(molecule)\nassert not f(molecule).filter_result\n\n\nsource\n\n\nTemplate\n\n Template (filters:list[__main__.Filter])\n\nTemplate holds a list of filters and screens a molecule against all of them\n\n\n\n\nType\nDetails\n\n\n\n\nfilters\nlist\nlist of filters\n\n\n\n\nsource\n\n\nTemplateResult\n\n TemplateResult (result:bool, filter_results:list[bool],\n                 filter_data:list[typing.Optional[__main__.FilterResult]])\n\nContainer for template results\n\n\n\n\nType\nDetails\n\n\n\n\nresult\nbool\noverall pass/fail result\n\n\nfilter_results\nlist\npass/fail from individual filters\n\n\nfilter_data\nlist\nfilter data from individual filters\n\n\n\n\nhbd = mol_func_wrapper(rdMolDescriptors.CalcNumHBD)\nhba = mol_func_wrapper(rdMolDescriptors.CalcNumHBA)\nmolwt = mol_func_wrapper(rdMolDescriptors.CalcExactMolWt)\n\ndef logp(molecule):\n    return rdMolDescriptors.CalcCrippenDescriptors(molecule.mol)[0]\n\nfilters = [\n    ValidityFilter(),\n    SingleCompoundFilter(),\n    RangeFunctionFilter(hbd, 'hydrogen_bond_donors', None, 5),\n    RangeFunctionFilter(hba, 'hydrogen_bond_acceptors', None, 10),\n    RangeFunctionFilter(molwt, 'molecular_weight', None, 150),\n    RangeFunctionFilter(logp, 'CLogP', None, 5)\n]\n\ntemplate = Template(filters)\n\nmolecule = Molecule('c1ccccc1N=Nc1ccccc1')\n\nres = template(molecule, early_exit=True)\nassert res.result == False\nassert res.filter_results == [True, True, True, True, False, False]\n\nres = template(molecule, early_exit=False)\nassert res.result == False\nassert res.filter_results == [True, True, True, True, False, True]\n\nassert template(Molecule('c1ccccc1N=N')).result"
  },
  {
    "objectID": "tutorials/building_block_tutorial.html",
    "href": "tutorials/building_block_tutorial.html",
    "title": "Building Block Tutorial",
    "section": "",
    "text": "This tutorial shows how to use chem_templates building block assembly.\nBuilding blocks are chemical subunits that can be assembled via easy chemistry. Building blocks are a simple way to combinatorially generate diverse compounds. The chem_templates building block functions allow us to assemble molecules from building blocks and screen building blocks, intermediate products, and the final molecule with specific Template filters.\nIn this example, we will look at the simple case of assembling a molecule from two building blocks - BB1 + BB2 -&gt; product.\nWe can accomplish this with the following steps: 1. define templates 2. create synthon library 3. define assembly schema 4. assemble molecules"
  },
  {
    "objectID": "tutorials/building_block_tutorial.html#define-templates",
    "href": "tutorials/building_block_tutorial.html#define-templates",
    "title": "Building Block Tutorial",
    "section": "Define Templates",
    "text": "Define Templates\nWe need a template for each building block, as well as the final product. For simplicity, we will use Rule of 3 filters for the individual building blocks, and the Rule of 5 filters for the final molecule\n\nfrom chem_templates.utils import *\nfrom chem_templates.chem import Molecule\nfrom chem_templates.building_blocks import molecule_to_synthon, REACTION_GROUPS, ReactionUniverse\nfrom chem_templates.assembly import AssemblyInputs, SynthonNode, SynthonLeafNode\nfrom chem_templates.filter import (\n    RangeFunctionFilter, \n    ValidityFilter, \n    SingleCompoundFilter, \n    SmartsFilter,\n    Template\n)\n\nfrom rdkit.Chem import rdMolDescriptors, Descriptors\nfrom rdkit.Chem import Draw\n\n\ndef hbd(molecule):\n    return rdMolDescriptors.CalcNumHBD(molecule.mol)\n\ndef hba(molecule):\n    return rdMolDescriptors.CalcNumHBA(molecule.mol)\n\ndef molwt(molecule):\n    return rdMolDescriptors.CalcExactMolWt(molecule.mol)\n\ndef logp(molecule):\n    return Descriptors.MolLogP(molecule.mol)\n\ndef rotb(molecule):\n    return rdMolDescriptors.CalcNumRotatableBonds(molecule.mol)\n\n\n# building block\nbb_template = Template([\n    RangeFunctionFilter(hbd, 'hydrogen_bond_donors', None, 3),\n    RangeFunctionFilter(hba, 'hydrogen_bond_acceptors', None, 3),\n    RangeFunctionFilter(molwt, 'molecular_weight', None, 300),\n    RangeFunctionFilter(logp, 'CLogP', None, 3),\n    RangeFunctionFilter(rotb, 'rotatable_bonds', None, 3)\n])\n\n# full\nfull_template = Template([\n    ValidityFilter(),\n    SingleCompoundFilter(),\n    RangeFunctionFilter(hbd, 'hydrogen_bond_donors', None, 5),\n    RangeFunctionFilter(hba, 'hydrogen_bond_acceptors', None, 10),\n    RangeFunctionFilter(molwt, 'molecular_weight', None, 500),\n    RangeFunctionFilter(logp, 'CLogP', None, 5),\n    SmartsFilter('[CX3](=O)[OX2H1]', 'carboxylic_acid', \n                 exclude=True, min_val=2, max_val=None), # at most 1 carboxylic acid in final molecule\n    SmartsFilter('[CX3](=[OX1])OCC', 'carboxylic_ester', \n                 exclude=True, min_val=1, max_val=None) # no carboxylic acid reactive group in final molecule\n])"
  },
  {
    "objectID": "tutorials/building_block_tutorial.html#create-synthon-library",
    "href": "tutorials/building_block_tutorial.html#create-synthon-library",
    "title": "Building Block Tutorial",
    "section": "Create Synthon Library",
    "text": "Create Synthon Library\nNow we need to create a library of synthons. A synthon is a hypothetical molecule that represents a building block after reaction. Reactive groups are converted to placeholder molecules. Later, we will use the placeholders to simulate building block assembly. A single molecule can have multiple synthons.\n\nmolecule = Molecule('CCOC(=O)c1c(N)ccnc1C(F)(F)F')\nsynthons = molecule_to_synthon(molecule)\nDraw.MolsToGridImage([molecule.mol]+[i.mol for i in synthons], \n                     legends=['Building Block'] + [f'synthon {i+1}' for i in range(len(synthons))],\n                     subImgSize=(300,300))\n\n\n\n\n\nbuilding_blocks = ['CCOC(=O)c1c(N)ccnc1C(F)(F)F',\n 'COC(=O)C(C)N=C=O',\n 'CCOC(=O)c1[nH]c2ccc(C)cc2c1N',\n 'COC(=O)c1c(N)sc2c1CCC(C)C2',\n 'O=C(NC[C@@H]1C[C@H](F)CN1)OCc1ccccc1',\n 'O=C(NCC1CCNCC1)OCc1ccccc1',\n 'NCC1CCCN(C(=O)OCc2ccccc2)C1',\n 'CC(C)(CN)NC(=O)OCc1ccccc1',\n 'O=C(NCC1CCCCN1)OCc1ccccc1',\n 'C[C@@H]1CNCCN1C(=O)OCc1ccccc1',\n 'NCC1CCN(C(=O)OCc2ccccc2)C1',\n 'CCC1CNCCN1C(=O)OCc1ccccc1',\n 'CNC1CCN(C(=O)OCc2ccccc2)CC1',\n 'NC[C@@H]1CCN(C(=O)OCc2ccccc2)C1',\n 'NC1CCN(C(=O)OCc2ccccc2)CC1F',\n 'NC[C@H]1CCCN1C(=O)OCc1ccccc1',\n 'N[C@@H]1C[C@H](C(=O)O)N(C(=O)OCc2ccccc2)C1',\n 'O=C(OCc1ccccc1)N1CCN[C@H](Cc2ccccc2)C1',\n 'O=C(OCc1ccccc1)N1CCC2(CCCCN2)C1',\n 'O=C(OCc1ccccc1)N1CCCC2NCCC21',\n 'C[C@H](N)C(=O)NCC1CCCCN1C(=O)OCc1ccccc1',\n 'CC(C)[C@H](N)C(=O)N1CCCCC1CNC(=O)OCc1ccccc1',\n 'NCC(=O)N1CCCC(CNC(=O)OCc2ccccc2)C1',\n 'O=C(O)CN[C@@H]1CCCN(C(=O)OCc2ccccc2)C1',\n 'CCN(C(=O)OCc1ccccc1)C1CCNCC1',\n 'NCC(=O)NC[C@@H]1CCCN1C(=O)OCc1ccccc1',\n 'C[C@H](N)C(=O)NC[C@@H]1CCCN1C(=O)OCc1ccccc1',\n 'CCN(C(=O)OCc1ccccc1)[C@@H]1CCN(C(=O)CN)C1',\n 'CCN(C(=O)OCc1ccccc1)[C@H]1CCN(C(=O)[C@H](C)N)C1',\n 'CC(C)NC[C@@H]1CCCN1C(=O)OCc1ccccc1',\n 'O=C(OCc1ccccc1)N(CC1CCNC1)C1CC1',\n 'CCN(C(=O)[C@H](C)N)C1CCCCC1NC(=O)OCc1ccccc1',\n 'CNC1CCCCC1N(C(=O)OCc1ccccc1)C(C)C',\n 'O=C(NC[C@@H]1CNCCO1)OCc1ccccc1',\n 'CN(C(=O)OCc1ccccc1)C1CCCNC1',\n 'O=C(OCc1ccccc1)N1C[C@H]2CNCC[C@H]21',\n 'O=C(OCc1ccccc1)N1CCCC2(CCN2)C1',\n 'NC1(C(F)(F)F)CCN(C(=O)OCc2ccccc2)CC1',\n 'NC1CCCCN(C(=O)OCc2ccccc2)C1',\n 'CCOC(=O)C(OC(=O)C(Cc1ccccc1)NC=O)c1ccccc1',\n 'COC(=O)c1cc(-c2c(F)cccc2COC(=O)C(Cc2ccccc2)NC=O)ccc1F',\n 'COC(=O)c1ccc(F)c(-c2cc(COC(=O)C(Cc3ccccc3)NC=O)ccc2F)c1',\n 'COC(=O)c1cccc(-c2cccc(COC(=O)C(Cc3ccccc3)NC=O)c2C)c1',\n 'CCOC(=O)c1[nH]c2ccc(Br)cc2c1C=O',\n 'COC(=O)COc1c(Cl)cc(C=O)cc1Cl',\n 'COC(=O)C(NNc1ccccc1)(NC(=O)CC(C)C)C(F)(F)F',\n 'CCOC(=O)COc1ccc(Cl)cc1C=O',\n 'CCOC(=O)c1c(C)c(C=O)n(C)c1C',\n 'CCOC(=O)c1nc2cc(C)ccn2c1C=O',\n 'COC(=O)Cn1cc(C=O)c2cc(OC)ccc21',\n 'CCOC(=O)c1nn(-c2ccc(Cl)cc2)cc1C=O',\n 'CCOC(=O)C1CCN(c2ccccc2C=O)CC1',\n 'COC(=O)c1cc(F)cc(C=O)c1F',\n 'COC(=O)c1cccc(C=O)c1OC',\n 'COC(=O)c1cc(Br)c2c(C=O)n[nH]c2c1',\n 'COC(=O)c1c(C=O)c(C)n(C)c1C',\n 'CCOC(=O)c1nn(-c2cccc(Cl)c2)cc1C=O',\n 'COC(=O)C(C)(C)CC=O',\n 'COC(=O)c1ccc(Cl)c(C=O)c1',\n 'COC(=O)c1oc(C=O)cc1C',\n 'COC(=O)c1c[nH]c(C=O)c1C1CC1',\n 'COC(=O)c1ncc(C=O)cc1Cl',\n 'CCOC(=O)c1c(Cl)ccc(C=O)c1F',\n 'COC(=O)CC=O',\n 'CCOC(=O)C1CCCCN1c1ccccc1C=O',\n 'CCOc1ccc(C(=O)OC)cc1C=O',\n 'COC(=O)N[C@H](C=O)C(C)C',\n 'COC(=O)Nc1ccc(C=O)c([N+](=O)[O-])c1',\n 'COC(=O)c1cc2n(c1C=O)CCCC2',\n 'CCOC(=O)c1cn(C)c2cc(C=O)ccc2c1=O',\n 'COC(=O)C1CCN(C(=O)OC(C)(C)C)C=C1C=O',\n 'CCOC(=O)c1ncn(C)c1C=O',\n 'CCOC(=O)c1cc(F)c(C=O)cc1F',\n 'CCOC(=O)Cc1cccc(C=O)c1',\n 'COC(=O)C(Cl)=C(Cl)C=O',\n 'COC(=O)c1cccc(NC(=O)C=O)c1',\n 'CCOC(=O)c1cc2cc(C=O)sc2[nH]1',\n 'COC(=O)Cn1cc(C=O)c(C(F)(F)F)n1',\n 'CCOC(=O)C1(CC=O)CCCN(C(=O)OC(C)(C)C)C1',\n 'COC(=O)/C=C/C=O',\n 'COC(=O)c1cc(Cl)cc(C=O)n1',\n 'CCOC(=O)c1c(C#N)cc(Br)cc1C=O',\n 'COC(=O)C(C=O)c1cccc(F)c1',\n 'COC(=O)c1c(C#N)ccc(Br)c1C=O',\n 'CCOC(=O)Cc1cc(Br)c(C=O)cc1C#N',\n 'COC(=O)Cc1cc(Br)c(C=O)cc1C#N',\n 'CCOC(=O)c1[nH]c2c(C)cc(F)cc2c1C=O',\n 'CCOC(=O)C1C(CC)NC(=S)NC1(C)O',\n 'O=C(O)CCN=C=S',\n 'COC(=O)[C@@H]1CO[C@H](C(C)(C)C)N1C=O',\n 'CCOC(=O)CNC(=S)N1CCN(C=O)CC1',\n 'COC(=O)c1ccc(OC=O)cc1',\n '[N-]=[N+]=Nc1cccc(S(=O)(=O)F)c1',\n 'COC(=O)c1ccc(C)c(S(=O)(=O)Cl)c1',\n 'COC(=O)c1c(Cl)ccc(S(=O)(=O)Cl)c1Cl',\n 'COC(=O)c1ccc(S(=O)(=O)Cl)cc1Cl',\n 'CCOC(=O)c1ccc(F)c(S(=O)(=O)Cl)c1',\n 'CCOC(=O)C(C)S(=O)(=O)Cl']\n\n\nmolecules = [Molecule(i) for i in building_blocks]\nsynthons = deduplicate_list(flatten_list([molecule_to_synthon(i) for i in molecules]), \n                            key_func=lambda x: x.smile)\nlen(synthons)\n\n468\n\n\nWe can check the compatibility between two synthons to see if they can react:\n\n# note exact index values may change\ns1 = synthons[0]\ns2 = synthons[153]\nprint(s1.is_compatible(s2))\n\nTrue\n\n\nTo actually react them, we need to use a reaction template. Reactions are represented in the following way:\n\nA FusionReaction holds a specific set of reaction SMARTS.\nA ReactionGroup holds several FusionReaction of the same reaction type (ie there are multiple N-acylation reaction SMARTS)\nA ReactionUniverse holds a list of ReactionGroup objects\n\nSeveral reaction groups are provided:\n\nfor item in REACTION_GROUPS:\n    print(item)\n\nReaction Class: O-acylation\n    Reaction: Alcohol/Phenol acylation\n    Reaction: O-Acylation by O=C(+)-X reagents\n    Reaction: O-Acylation of O-X compounds\nReaction Class: Olefination\n    Reaction: Knovenagel-, Wittig-, Julia-Kocienski- type reactions\n    Reaction: Olefin Metathesis\nReaction Class: Condensation_of_Y-NH2_with_carbonyl_compounds\n    Reaction: Condensation of Y-NH2 with carbonyl compounds\nReaction Class: Amine_sulphoacylation\n    Reaction: Amine sulphoacilation\nReaction Class: C-C couplings\n    Reaction: Suzuki cross-coupling C(Ar)- C(Ar)\n    Reaction: Suzuki coupling C(sp2) - C(sp2)\n    Reaction: Heck and Suzuki coupling C(Ar) - C(sp2)\n    Reaction: Sonogashira coupling C(Ar) - C(sp)\n    Reaction: Novel methods for C(Ar)-C(sp3) coupling\n    Reaction: Novel methods for C(Ar)-C(sp3) coupling with boronics\nReaction Class: Radical_reactions\n    Reaction: Minisci reaction and Baran diversinates C(Ar)-C(sp3)\n    Reaction: Giese reaction C(sp3) - C(sp3)\nReaction Class: N-acylation\n    Reaction: Amine acylation\n    Reaction: N-Acylation of RN-X compounds\n    Reaction: N-Acylation by O=C(+)-X reagents (except isocyanates - R1.4)\n    Reaction: Amine acylation by isocyanates or analogues\nReaction Class: O-alkylation_arylation\n    Reaction: O-SN alkylation\n    Reaction: Cu-mediated C-O coupling\n    Reaction: O-C Chan-Evans-Lam coupling\n    Reaction: N-O-alkylation\nReaction Class: Metal organics C-C bong assembling\n    Reaction: Addition of Li, Mg, Zn organics to aldehydes and ketones\n    Reaction: Acylation of Li, Mg, Zn organics\nReaction Class: S-alkylation_arylation\n    Reaction: S-alkylation arylation\n    Reaction: Simple alkylation of sulphinic acid salts\n    Reaction: Cu-catalyzed arylation of sulphinic acid salts\nReaction Class: Alkylation_arylation_of_NH-lactam\n    Reaction: NH-lactam SN alkylation\n    Reaction: NH-lactam Chan-Evans-Lam coupling\n    Reaction: NH-lactam Cu-mediated C-N coupling\nReaction Class: Alkylation_arylation_of_NH-heterocycles\n    Reaction: nH-SN alkylation\n    Reaction: nH-Chan-Evans-Lam coupling\n    Reaction: nH-Cu-mediated C-N coupling\nReaction Class: Amine_alkylation_arylation\n    Reaction: SN alkylation of amines\n    Reaction: Buchwald-Hartwig amination(BHA), Cu-mediated C-N coupling\n    Reaction: Umpolung cross-coupling\n    Reaction: Tertiary amines alkylation arylation\n\n\nFor this example, we will create a ReactionUniverse with all the available groups. Note that currently there are no cheminformatics checks on reaction compatibility for multiple reaction chains.\n\nrxn_universe = ReactionUniverse('all_rxns', REACTION_GROUPS)\n\nNow we can see which reactions match a compatible synthon pair\n\nmatching_rxns = rxn_universe.get_matching_reactions(s1, s2)\nprint(matching_rxns)\n\n[Reaction: SN alkylation of amines]\n\n\n\nrxn = matching_rxns[0]\nproduct = rxn.react(s1, s2)\n\n\nDraw.MolsToGridImage([s1.mol, s2.mol, product[0].mol], legends=['Synthon1', 'Synthon2', 'Product'],\n                    subImgSize=(300,300))\n\n\n\n\nA note on working with synthons:\nIn the above, synthon1 and synthon2 still have reactive groups present on the molecule (carboxylic acid and carboxylic ester). This is because we generate a variety of synthons for each input building block based on the functional groups and reaction pathways available (see image below).\nIf you want to ensure specific reactive groups or protecting groups aren’t present on final molecules, use a SMARTS filter in your template to eliminate them\n\nDraw.MolsToGridImage([i.mol for i in molecule_to_synthon(s2.data['parents'][0])], molsPerRow=6)"
  },
  {
    "objectID": "tutorials/building_block_tutorial.html#define-assembly-schema",
    "href": "tutorials/building_block_tutorial.html#define-assembly-schema",
    "title": "Building Block Tutorial",
    "section": "Define Assembly Schema",
    "text": "Define Assembly Schema\nNow we define how our building blocks will fit together.\nFirst we define our leaf nodes with the SynthonLeafNode class. Each leaf node has a name, a set of n_func values, and a template.\nThe n_func values define how many functional groups a building block is allowed to have. So n_func=set([1]) would only allow building blocks with 1 functional group. n_func=set([2,3]) would allow building blocks with 2-3 functional groups.\nNote that as discussed above, n_func looks at the annotated functional groups on the synthon, so will not exclude multi-functional building blocks with un-annotated groups.\nSince we want to assemble two building blocks into a final molecule, we will set n_func=set([1]) for each building block:\n\nbb1 = SynthonLeafNode('bb1', set([1]), bb_template)\nbb2 = SynthonLeafNode('bb2', set([1]), bb_template)\n\nNow we make the product node with the SynthonNode class, passing in our input nodes and reaction universe\n\nprod = SynthonNode('product', bb1, bb2, rxn_universe, set([0]), full_template)"
  },
  {
    "objectID": "tutorials/building_block_tutorial.html#assemble-library",
    "href": "tutorials/building_block_tutorial.html#assemble-library",
    "title": "Building Block Tutorial",
    "section": "Assemble Library",
    "text": "Assemble Library\nTo assemble, first we run prod.build_assembly_pools(synthons) which builds a dictionary of assembly pools based on which synthons match the n_func and template specifications at the leaf nodes.\nThen we create the AssemblyInputs and pass them to prod.assemble(assembly_inputs)\n\nassembly_dict = prod.build_assembly_pools(synthons)\nassembly_dict\n\n{'bb1': AssemblyPool: 180 items, 'bb2': AssemblyPool: 180 items}\n\n\n\nassembly_inputs = AssemblyInputs(assembly_dict, 1000, 1000)\n\n\nassembled = prod.assemble(assembly_inputs)\nassembled\n\nbb1\nbb2\nproduct\n\n\nAssemblyPool: 1497 items\n\n\nNow we can review the assembled molecules. We can see some of these still contain reactive groups. These can be triaged if needed by adding additional smarts filters\n\nDraw.MolsToGridImage([assembled[i].mol for i in range(15)], molsPerRow=5, subImgSize=(300,300))"
  },
  {
    "objectID": "tutorials/building_block_tutorial.html#other-assembly-schemas",
    "href": "tutorials/building_block_tutorial.html#other-assembly-schemas",
    "title": "Building Block Tutorial",
    "section": "Other Assembly Schemas",
    "text": "Other Assembly Schemas\nConsider assembling 3 building blocks. Our assembly schema would follow: * select first building block * select second building block * select matching reactions * react and generate products * select third building block * select matching reactions * react and generate products\nWe may want to impose different potential reactions at each step. We can do this by specifying different ReactionUniverse at the different product nodes. An example schema would look something like this:\nbb1 = SynthonLeafNode('bb1', set([1]), bb_template1) # first building block with 1 functional group\nbb2 = SynthonLeafNode('bb2', set([2]), bb_template2) # middle building block with 2 functional groups\nbb3 = SynthonLeafNode('bb3', set([3]), bb_template3) # final building block with 1 functional group\n\nproduct1 = SynthonNode('product1', bb1, bb2, rxn_universe1, \n                       set([1]), prod1_template) # first product with 1 remaining functional group\n\nproduct2 = SynthonNode('product2', product1, bb3, rxn_universe2, \n                       set([0]), prod2_template) # final product with 0 remaining functional groups"
  },
  {
    "objectID": "fragments.html",
    "href": "fragments.html",
    "title": "Fragments",
    "section": "",
    "text": "source\n\nfuse_smile_on_atom_mapping\n\n fuse_smile_on_atom_mapping (smile:str)\n\nAttempts to fuse mapped SMILES into a single molecule (ie [*:1]C.[*:1]N -&gt; CN). Returns None if fusion failed\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\ninput SMILES string\n\n\nReturns\nstr\noutput fused SMILES string\n\n\n\n\nsource\n\n\nfuse_mol_on_atom_mapping\n\n fuse_mol_on_atom_mapping (mol:rdkit.Chem.rdchem.Mol)\n\nAttempts to fuse mapped molecules into a single molecule (ie [*:1]C.[*:1]N -&gt; CN). Returns None if fusion failed\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nmol\nChem.Mol\ninput rdkit Mol\n\n\nReturns\nUnion[Chem.Mol, None]\noutput fused Mol, returns None if failed\n\n\n\n\nassert fuse_smile_on_atom_mapping('[*:1]C.[*:1]N') == 'CN'\n\n\nsource\n\n\nadd_fragment_mapping\n\n add_fragment_mapping (smile:str, map_nums:list[int])\n\nGiven an unmapped fragment SMILES string and a list of mapping ints, adds mapping to SMILES.\nie add_fragment_mapping('*C*', [3,4]) -&gt; [*:3]C[*:4]\nNumber of * dummy atoms should match length of map_nums\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\nSMILES string\n\n\nmap_nums\nlist[int]\nfragment mapping ints\n\n\nReturns\nstr\nmapped SMILES\n\n\n\n\nsource\n\n\nremove_fragment_mapping\n\n remove_fragment_mapping (smile:str)\n\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\nmapped SMILES string\n\n\nReturns\nstr\nunmapped SMILES string\n\n\n\n\nassert add_fragment_mapping('*C', [1]) == 'C[*:1]'\nassert remove_fragment_mapping('C[*:1]') == '*C'\n\n\nsource\n\n\ncombine_dummies\n\n combine_dummies (dummies:list[rdkit.Chem.rdchem.Mol], fuse:bool=True)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndummies\nlist[Chem.Mol]\n\nlist of dummy mols\n\n\nfuse\nbool\nTrue\nif mols should be fused\n\n\nReturns\nChem.Mol\n\nreturns output mol\n\n\n\n\nsource\n\n\nget_dummy_mol\n\n get_dummy_mol (name:str, map_nums:list[int], id:Optional[int]=None)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nname\nstr\n\ndummy name\n\n\nmap_nums\nlist[int]\n\ndummy mapping nums\n\n\nid\nOptional[int]\nNone\noptional dummy ID\n\n\nReturns\nChem.Mol\n\nreturns dummy mol\n\n\n\n\ndummies = [get_dummy_mol('R1', [1]), get_dummy_mol('R2', [1])]\nassert [to_smile(i) for i in dummies] == ['[Zr][*:1]', '[Zr][*:1]']\nfused = combine_dummies(dummies)\nassert to_smile(fused) == '[Zr][Zr]'\n\n\nsource\n\n\nmatch_mapping\n\n match_mapping (molecule:chem_templates.chem.Molecule,\n                mapping_idxs:list[int])\n\n\n\n\n\nType\nDetails\n\n\n\n\nmolecule\nMolecule\ninput Molecule\n\n\nmapping_idxs\nlist[int]\nmapping ints\n\n\nReturns\nbool\nTrue if mapping matches, else False\n\n\n\n\nsource\n\n\nis_mapped\n\n is_mapped (smile:str)\n\ndetermines mapping status by matching number of * dummy atoms with number of [*:x] mapping IDs\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\nSMILES string\n\n\nReturns\nbool\nTrue if mapped, else False\n\n\n\n\nassert not is_mapped('*C')\nassert is_mapped('[*:1]C')\nassert not is_mapped('[*:1]C*')\nassert match_mapping(Molecule('[*:2]C'), [2])\nassert not match_mapping(Molecule('[*:2]C'), [1])\n\n\nsource\n\n\ngenerate_mapping_permutations\n\n generate_mapping_permutations (smile:str, map_nums:list[int],\n                                exact:bool=False)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsmile\nstr\n\nSMILES string\n\n\nmap_nums\nlist[int]\n\npossible mapping ints\n\n\nexact\nbool\nFalse\nif True, number of map_nums must match number of * atoms\n\n\nReturns\nlist[str]\n\nlist of mapped SMILES\n\n\n\n\nassert generate_mapping_permutations('*C*', [2,3,4]) == ['C([*:2])[*:3]',\n 'C([*:2])[*:4]',\n 'C([*:2])[*:3]',\n 'C([*:3])[*:4]',\n 'C([*:2])[*:4]',\n 'C([*:3])[*:4]']\n\n\nsource\n\n\nmatch_and_map\n\n match_and_map (fragment:str, mapping_idxs:list[int])\n\n\n\n\n\nType\nDetails\n\n\n\n\nfragment\nstr\nfragment SMILES\n\n\nmapping_idxs\nlist[int]\nmapping ints\n\n\nReturns\nlist[str]\nlist of mapped SMILES\n\n\n\n\nassert match_and_map('*C*', [1,2]) == ['C([*:1])[*:2]', 'C([*:1])[*:2]']\nassert match_and_map('C([*:1])[*:2]', [4,5]) == []\nassert match_and_map('C([*:1])[*:2]', [1,2]) == ['C([*:1])[*:2]']\n\n\nsource\n\n\nshred_smiles\n\n shred_smiles (smiles:list[str], cuts:list[int], max_fragment_length:int,\n               generations:int, keep_long_fragments:bool, worker_pool:Opti\n               onal[&lt;boundmethodBaseContext.Poolof&lt;multiprocessing.context\n               .DefaultContextobjectat0x7fce59bc5130&gt;&gt;]=None)\n\ngiven a list of SMILES smiles, each SMILES string is fragmented with cuts (see fragment_smile). After fragmentation, all fragments longer than max_fragment_length are re-fragmented. Repeats for generations iterations. If keep_long_fragments=True, all fragments are returned. Else, only fragments shorter than max_fragment_length are returned.\nkeep_long_fragments=False is recommended as molecules tend to generate very large fragments (ie just cleaving off a methyl group)\n\nsource\n\n\nclean_fragments\n\n clean_fragments (fragments:list[str], remove_mapping:bool=True)\n\ncleans fragments, deduplicates them, and splits multi-compound fragments\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfragments\nlist[str]\n\nlist of input fragments\n\n\nremove_mapping\nbool\nTrue\nif mapping should be removed (ie [*:1]C -&gt; *C)\n\n\nReturns\nlist[str]\n\nlist of cleaned fragments\n\n\n\n\nsource\n\n\nfragment_smile\n\n fragment_smile (smile:str, cuts:list[int])\n\n\n\n\n\nType\nDetails\n\n\n\n\nsmile\nstr\ninput SMILES string\n\n\ncuts\nlist[int]\nnumber of cuts, ie [1,2,3]\n\n\nReturns\nlist[str]\nlist of fragments\n\n\n\n\nassert fragment_smile('CCC', [1,2]) == ['', 'CC[*:1].C[*:1]', 'C([*:1])[*:2]', 'C[*:1].C[*:2]']\nassert clean_fragments(fragment_smile('CCC', [1,2])) == ['*C', '*C*', '*CC']"
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utils",
    "section": "",
    "text": "source\n\nflatten_list\n\n flatten_list (input:list[list])\n\nFlattens list of lists (not recursive)\n\n\n\n\nType\nDetails\n\n\n\n\ninput\nlist\nnested list\n\n\nReturns\nlist\nflattened list\n\n\n\n\nassert flatten_list([[1], [2]]) == [1, 2]\n\n\nsource\n\n\ndeduplicate_list\n\n deduplicate_list (input:list, key_func:Optional[Callable]=None)\n\ndeduplicates list while maintaining order\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ninput\nlist\n\ninput list containing duplicates\n\n\nkey_func\ntyping.Optional[typing.Callable]\nNone\nfunction to generate deduplication keys\n\n\nReturns\nlist\n\noutput list, deduplicated\n\n\n\n\nassert deduplicate_list([1,2,2,3,5,3]) == [1, 2, 3, 5]\nassert deduplicate_list(['C', 'CC', 'CN'], key_func=lambda x: len(x)) == ['C', 'CN']\n\n\nsource\n\n\nvalidate_range\n\n validate_range (min_val:Union[int,float,NoneType],\n                 max_val:Union[int,float,NoneType],\n                 min_limit:Union[int,float], max_limit:Union[int,float])\n\ngiven a range min_val, max_val, and range limits min_limit, max_limit, this function verifies that min_limit &lt; min_val &lt; max_val &lt; max_limit and returns the resolved range\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nmin_val\ntyping.Union[int, float, NoneType]\nminimum range value\n\n\nmax_val\ntyping.Union[int, float, NoneType]\nmaximum range value\n\n\nmin_limit\ntyping.Union[int, float]\nmin value limit - replaces min_val if min_val is None\n\n\nmax_limit\ntyping.Union[int, float]\nmax value limit - replaces max_val if max_val is None\n\n\nReturns\ntyping.Tuple[typing.Union[int, float], typing.Union[int, float]]\nresolved [min_val, max_val] range"
  }
]